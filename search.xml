<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ABAC权限模型</title>
    <url>/2020/05/08/ABAC%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="ABAC基于属性的访问控制"><a href="#ABAC基于属性的访问控制" class="headerlink" title="ABAC基于属性的访问控制"></a>ABAC基于属性的访问控制</h3><h3 id="1-什么是ABAC权限模型"><a href="#1-什么是ABAC权限模型" class="headerlink" title="1. 什么是ABAC权限模型"></a>1. 什么是ABAC权限模型</h3><p>基于属性的访问控制（Attribute-Based Access Control）是一种灵活的授权模型。是通过实体的属性、操作类型、相关的环境来控制是否有对操作对象的权限。</p>
<a id="more"></a>

<h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h3><p>例如规则：“允许所有班主任在上课时间自由进出校门”这条规则，其中，“班主任”是用户的角色属性，“上课时间”是环境属性，“进出”是操作属性，而“校门”就是对象属性了。</p>
<blockquote>
<p>规定哪些<strong>属性的主体</strong>可以对哪些<strong>属性的资源</strong>在哪些<strong>属性的情况</strong>下进行哪些<strong>操作</strong></p>
</blockquote>
<p>ABAC其中的属性就是与主体、资源、情况相关的所有信息。</p>
<ul>
<li>主体的属性：指的是与主体相关的所有信息，包括主体的年龄、性别、职位等。</li>
<li>资源的属性：指的是与资源相关的所有信息，包括资源的创建时间、创建位置、密级等。</li>
<li>情况的属性：指的是客观情况的属性，比如当前的时间、当前的位置、当前的场景（普通状态、紧急状态）。</li>
</ul>
<h3 id="3-与RBAC权限模型的对比"><a href="#3-与RBAC权限模型的对比" class="headerlink" title="3. 与RBAC权限模型的对比"></a>3. 与RBAC权限模型的对比</h3><blockquote>
<p>RBAC虽然是目前最普遍的权限控制模型。但是某些情况下，RBAC是无法满足并且也实现不了的。比如业务员1和业务员2都属于业务员角色，都有查看客户订单的权限。当有一个需求，要求业务员1只能查看北京地区的客户的订单，业务员2只能查看上海的客户的订单。这单单使用RBAC是无法实现。借助RBAC，可行的做法是，分地区创建角色，然后程序中根据角色做数据的过滤，这种做法缺点之前也提到过，需求变更的时候可能需要每次都修改代码。</p>
</blockquote>
<h5 id="ABAC对于RBAC有以下优点"><a href="#ABAC对于RBAC有以下优点" class="headerlink" title="ABAC对于RBAC有以下优点"></a>ABAC对于RBAC有以下优点</h5><ul>
<li>对于大型组织，基于RBCA的控制模型需要维护大量的角色和授权关系，相比而言，ABAC更加灵活；对于中小型组织，维护角色和授权关系的工作量不大，反而定制各种策略相对麻烦，更容易接受RBAC授权模型。</li>
<li>新增资源时，ABAC仅需要维护较少的资源。而RBAC需要维护所有相关的角色。ABAC可扩展性更强、更方便。</li>
<li>RBAC支持带有动态参数的授权规则，RBAC只能基于静态的参数进行判断。</li>
<li>ABAC权限控制的粒度比RBAC更细。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>20个值得学习的python小技巧</title>
    <url>/2019/12/03/20%E4%B8%AA%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84python%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<ol>
<li><p><strong>使用切片反转字符串</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1=<span class="string">&quot;qwert&quot;</span> </span><br><span class="line">rev_str1=str1[::<span class="number">-1</span>] </span><br><span class="line"><span class="comment">#输出  </span></span><br><span class="line"><span class="comment"># trewq</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><p><strong>使首字母大写：title()方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1=<span class="string">&quot;this is a book&quot;</span> </span><br><span class="line">print(str1.title()) </span><br><span class="line"><span class="comment"># This Is A Book</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在字符串中查找所有的唯一元素</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1=<span class="string">&quot;aabbccccdddd&quot;</span></span><br><span class="line">set1=<span class="built_in">set</span>(str1) </span><br><span class="line">new_str=<span class="string">&#x27;&#x27;</span>.join(set1) </span><br><span class="line">print(new_str)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重复打印字符串或列表</strong></p>
<p>下面的代码中，对字符串或列表使用（*）。把字符串或列表复制多次。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="number">4</span> </span><br><span class="line">str1=<span class="string">&quot;abcd&quot;</span> </span><br><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>] </span><br><span class="line">print(str1*i) </span><br><span class="line"><span class="comment"># abcdabcdabcdabcd  </span></span><br><span class="line">print(list1*i) </span><br><span class="line"><span class="comment"># [1,2,1,2,1,2,1,2]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列表推导式</strong></p>
<p>列表推导式为我们提供了一种在其他列表基础上创建列表的好方法。</p>
<p>将旧列表的每个元素乘以 2 来创建新列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line">new_list1 = [<span class="number">2</span>*i <span class="keyword">for</span> i <span class="keyword">in</span> list1] </span><br><span class="line"><span class="comment"># [2,4,6]</span></span><br></pre></td></tr></table></figure>

<p>推导式配合range生成一个列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">print(a_list)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>交换变量</strong></p>
<p>不使用另一个变量，实现变量交换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="number">1</span> </span><br><span class="line">y=<span class="number">2</span> </span><br><span class="line">x, y = y, x </span><br><span class="line">print(x) <span class="comment"># 2  </span></span><br><span class="line">print(y) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将字符串拆分为子字符串列表(分割字符串)</strong></p>
<p>我们使用字符串类中的.split（）方法将字符串拆分为子字符串列表，还可以将要分割的分隔符作为参数传递。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;This is a book&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;test/ str 2&quot;</span></span><br><span class="line">print(str1.split()) <span class="comment"># [&#x27;This&#x27;, &#x27;is&#x27;, &#x27;a&#x27;, &#x27;book&#x27;] </span></span><br><span class="line">print(str2.split(<span class="string">&#x27;/&#x27;</span>)) <span class="comment"># [&#x27;test&#x27;, &#x27; str 2&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将字符串列表组合成单个字符串(拼接字符串)</strong></p>
<p>join（）将作为参数传递的字符串列表组合为单个字符串。这种情况下，我们使用逗号分隔符将它们分开。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_str=[<span class="string">&#x27;This&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;book&#x27;</span>]</span><br><span class="line">print(<span class="string">&#x27;,&#x27;</span>.join(list_str))</span><br><span class="line"><span class="comment"># This,is,a,book</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查回文字符串</strong></p>
<p>我们已经讨论过如何反转字符串，因此回文字符串在 Python 中判断起来非常简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1=<span class="string">&quot;qqaabb&quot;</span></span><br><span class="line"><span class="keyword">if</span> str1==str1[::<span class="number">-1</span>]:</span><br><span class="line">  print(<span class="string">&quot;回文&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">&quot;不是&quot;</span>)</span><br><span class="line">  <span class="comment"># 不是</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>列表中的元素统计</strong></p>
<p>使用 Python Counter 类。Python 计数器跟踪容器中每个元素的频数， Counter()返回一个字典，元素作为键，频数作为值。</p>
<p>另外使用 most_common()函数来获取列表中的 出现次数最多的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">count = Counter(list1)</span><br><span class="line">print(count)	<span class="comment"># Counter(&#123;&#x27;c&#x27;: 3, &#x27;a&#x27;: 2, &#x27;b&#x27;: 1&#125;)</span></span><br><span class="line">print(count[<span class="string">&#x27;b&#x27;</span>])	<span class="comment"># 1</span></span><br><span class="line">print(count.most_common(<span class="number">1</span>))		<span class="comment"># [(&#x27;c&#x27;, 3)]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>判断两个字符串是否为异序词</strong></p>
<p>异序词是通过重新排列不同单词或短语的字母而形成的单词或短语。如果两个字符串的 Counter 对象相等，那么它们就是相同字母异序词对。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1, s2, s3 = <span class="string">&quot;acbde&quot;</span>, <span class="string">&quot;abced&quot;</span>, <span class="string">&quot;abcda&quot;</span></span><br><span class="line">c1, c2, c3 = Counter(s1), Counter(s2), Counter(s3)</span><br><span class="line">print(c1)</span><br><span class="line">print(c2)</span><br><span class="line">print(c3)</span><br><span class="line"><span class="keyword">if</span> c1 == c2:</span><br><span class="line">  print(<span class="string">&#x27;1和2是异序词&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> c1 == c3:</span><br><span class="line">   print(<span class="string">&#x27;1和3是异序词&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># c1：Counter(&#123;&#x27;a&#x27;: 1, &#x27;c&#x27;: 1, &#x27;b&#x27;: 1, &#x27;d&#x27;: 1, &#x27;e&#x27;: 1&#125;)</span></span><br><span class="line"><span class="comment"># c2：Counter(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 1, &#x27;c&#x27;: 1, &#x27;e&#x27;: 1, &#x27;d&#x27;: 1&#125;)</span></span><br><span class="line"><span class="comment"># c3：Counter(&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 1, &#x27;c&#x27;: 1, &#x27;d&#x27;: 1&#125;)</span></span><br><span class="line"><span class="comment"># 1和2是异序词</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常捕获：try-except-else</strong></p>
<p>try / except 是 Python 中的异常处理模块，添加 else 语句，会在 try 块中没有引发异常的情况下运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(a/b)</span><br><span class="line">    <span class="comment"># b为0的时候触发异常</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">&quot;除数为0&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;不存在异常&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&quot;此段总是会执行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 除数为0</span></span><br><span class="line"><span class="comment"># 此段总是会执行</span></span><br></pre></td></tr></table></figure>

<p>又涨知识了，在python中除0时会抛出异常：ZeroDivisionError</p>
</li>
<li><p><strong>通过枚举获取索引 / 值对</strong></p>
<p>遍历列表中的值及其索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1):</span><br><span class="line">    print(<span class="string">&#x27;&#123;0&#125;:&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(idx, val))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 0:a</span></span><br><span class="line"><span class="comment"># 1:b</span></span><br><span class="line"><span class="comment"># 2:c</span></span><br><span class="line"><span class="comment"># 3:d</span></span><br><span class="line"><span class="comment"># 4:e</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取对象的内存使用信息，引用计数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="comment"># 查看占用内存大小</span></span><br><span class="line">print(sys.getsizeof(a))</span><br><span class="line"><span class="comment"># 查看该对象的引用计数次数</span></span><br><span class="line">print(sys.getrefcount(a))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>合并两个字典</strong></p>
<p>在 Python 2 中，使用 update（）合并两个字典，Python 3 变得更加简单。</p>
<p>下面脚本中，两个字典被合并。在相交的情况下，使用第二个字典中的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">&#x27;app&#x27;</span>:<span class="number">9</span>,<span class="string">&#x27;banana&#x27;</span>:<span class="number">6</span>&#125;</span><br><span class="line">dic2 = &#123;<span class="string">&#x27;banana&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;orange&#x27;</span>:<span class="number">8</span>&#125;</span><br><span class="line">com_dict = &#123;**dic1, **dic2&#125;</span><br><span class="line"><span class="comment"># &#123;&#x27;apple&#x27;:9,&#x27;banana&#x27;:4,&#x27;orange&#x27;:8&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计算代码执行所需的时间</strong></p>
<p>使用time模块来计算执行代码所需的时间消耗多少毫秒。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">s_time=time.time()</span><br><span class="line">a,b=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">c=a+b </span><br><span class="line">e_time=time.time()</span><br><span class="line">time_taken_in_micro=(e_time-s_time)*(<span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line">print(<span class="string">&quot;程序运行的毫秒：&#123;0&#125; ms&quot;</span>.<span class="built_in">format</span>(time_taken_in_micro)) </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从列表中随机取样</strong></p>
<p>从给定列表中生成了 n 个随机样本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">ns = <span class="number">2</span></span><br><span class="line">samples = random.sample(list1, ns)</span><br><span class="line">print(samples)</span><br><span class="line">[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>或者使用secrets库生成随机样本进行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line">s_rand = secrets.SystemRandom()</span><br><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">ns = <span class="number">2</span></span><br><span class="line">samples = s_rand.sample(list1,ns)</span><br><span class="line">print(samples)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数字列表化</strong></p>
<p>将整数转换为数字列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = <span class="number">123456</span></span><br><span class="line"><span class="comment"># 使用map</span></span><br><span class="line">digit_list = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">str</span>(nums)))</span><br><span class="line">print(digit_list)</span><br><span class="line"><span class="comment"># [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment"># 使用列表表达式</span></span><br><span class="line">digit_list = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">str</span>(nums)]</span><br><span class="line">print(digit_list)</span><br><span class="line"><span class="comment"># [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>唯一性检查</strong></p>
<p>利用set特性检查列表中的元素是否唯一。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unique</span>(<span class="params">l</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="built_in">len</span>(<span class="built_in">set</span>(l)):</span><br><span class="line">      print(<span class="string">&quot;所有元素是唯一的&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      print(<span class="string">&quot;存在重复&quot;</span>)</span><br><span class="line">unique([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"> <span class="comment"># 所有元素是唯一的</span></span><br><span class="line">unique([<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"> <span class="comment"># 存在重复</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>“指针”解包操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">list_b = [<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>]</span><br><span class="line">list_ab = [*list_a, *list_b]</span><br><span class="line">print(list_ab)</span><br><span class="line"><span class="comment"># [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Django+Redis实现排行榜功能</title>
    <url>/2019/02/17/Django-Redis%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="Django-Redis实现排行榜功能"><a href="#Django-Redis实现排行榜功能" class="headerlink" title="Django+Redis实现排行榜功能"></a>Django+Redis实现排行榜功能</h2><h4 id="使用Redis的有序集合实现排行榜功能"><a href="#使用Redis的有序集合实现排行榜功能" class="headerlink" title="使用Redis的有序集合实现排行榜功能"></a>使用Redis的有序集合实现排行榜功能</h4><p>日常Web开发中存在着各种各样的排行榜，比如游戏中玩家的排名，音乐播放器中的听歌排行等。玩家在排行榜中的名词是实力的象征，所以名次也就成了核心玩家追求的目标。再举个反面例子，一个公</p>
<a id="more"></a>

<p>司内部的考勤系统，为了更好的呈现员工的考勤，可以将请假次数按倒序展示出来排行榜，方便直观的看出员工考勤。</p>
<h4 id="一个典型的考勤排行榜包括以下常见功能："><a href="#一个典型的考勤排行榜包括以下常见功能：" class="headerlink" title="一个典型的考勤排行榜包括以下常见功能："></a>一个典型的考勤排行榜包括以下常见功能：</h4><ol>
<li>能够记录员工的请假次数</li>
<li>能够查询排名前N的员工</li>
<li>正序、反序</li>
</ol>
<p>更进一步，上面的操作都需要再短时间内实时完成，这样才能最大程度发挥排行榜的作用</p>
<p>在用户量大的情况下，由于一个用户排名的上升，大量用户的排名也会随之发生变化，如果采用传统的关系型数据库（比如MySql）来实现排行榜，将会导致对数据库的频繁修改，性能得不到满足，而利用Redis的SortSet数据结构能够非常方便搞定。</p>
<h4 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h4><p>有序集合和集合一样也是 string 类型元素的集合,且<strong>不允许重复</strong>的成员。我们正是利用它有序、自动去重的特性</p>
<h5 id="redis示例"><a href="#redis示例" class="headerlink" title="redis示例"></a>redis示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd workflow <span class="number">2</span> uid1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange workflow <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;uid1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange workflow <span class="number">0</span> <span class="number">5</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;uid1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd workflow <span class="number">1</span> uid2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange workflow <span class="number">0</span> <span class="number">5</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;uid2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;uid1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zincrby workflow <span class="number">1</span> uid2</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zincrby workflow <span class="number">-1</span> uid2</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrange workflow <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;uid1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;uid2&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<h5 id="django示例"><a href="#django示例" class="headerlink" title="django示例"></a>django示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line"></span><br><span class="line">r = redis.Redis(host=host,port=port)</span><br><span class="line"></span><br><span class="line">r.zadd(<span class="string">&#x27;z&#x27;</span>,&#123;<span class="string">&#x27;冰箱&#x27;</span>:<span class="number">20</span>&#125;)</span><br><span class="line">r.zadd(<span class="string">&#x27;z&#x27;</span>,&#123;<span class="string">&#x27;手机&#x27;</span>:<span class="number">30</span>&#125;)</span><br><span class="line"></span><br><span class="line">print(r.zrange(<span class="string">&#x27;m&#x27;</span>,<span class="number">0</span>,<span class="number">10</span>,desc=<span class="literal">True</span>,withscores=<span class="literal">True</span>))  <span class="comment">#desc=True 倒序</span></span><br></pre></td></tr></table></figure>

<h4 id="django实现"><a href="#django实现" class="headerlink" title="django实现"></a>django实现</h4><p>现在回到我们的项目中，在创建好接口后直接用zincrby()方法来将某个元素进行相应的操作。</p>
<p>zincrby(‘key’,增减数量,增减的key)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 操作redis缓存</span></span><br><span class="line">r.zincrby(<span class="string">&quot;workflow&quot;</span>, <span class="number">1</span>, uid)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="构造一个返回排行榜数据的接口"><a href="#构造一个返回排行榜数据的接口" class="headerlink" title="构造一个返回排行榜数据的接口"></a>构造一个返回排行榜数据的接口</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowTop</span>(<span class="params">APIView</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line"></span><br><span class="line">        type_id = request.GET.get(<span class="string">&#x27;type_id&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取redis排行榜   [(b&#x27;27&#x27;, 1.0), (b&#x27;24&#x27;, 1.0)]</span></span><br><span class="line">        work_click = r.zrange(type_id, <span class="number">0</span>, <span class="number">-1</span>, desc=<span class="literal">True</span>, withscores=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> work_click:</span><br><span class="line"></span><br><span class="line">            res = []</span><br><span class="line">            ranking = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> work_click:</span><br><span class="line"></span><br><span class="line">                username = User.objects.get(pk=item[<span class="number">0</span>].decode()).username</span><br><span class="line">				</span><br><span class="line">                <span class="comment"># 名次</span></span><br><span class="line">                ranking += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                data = &#123;</span><br><span class="line">                    <span class="string">&#x27;ranking&#x27;</span>: ranking,</span><br><span class="line">                    <span class="string">&#x27;username&#x27;</span>: username,</span><br><span class="line">                    <span class="string">&#x27;count&#x27;</span>: <span class="built_in">int</span>(item[<span class="number">1</span>])</span><br><span class="line">                &#125;</span><br><span class="line">                res.append(data)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;data&#x27;</span>: res&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;暂无排行榜&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">400</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>ok，到这里后端的排行榜接口就已经完成了！</p>
]]></content>
  </entry>
  <entry>
    <title>Django处理数据并发问题</title>
    <url>/2020/09/23/Django%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Django处理数据并发问题"><a href="#Django处理数据并发问题" class="headerlink" title="Django处理数据并发问题"></a>Django处理数据并发问题</h2><h3 id="1-数据库并发处理问题"><a href="#1-数据库并发处理问题" class="headerlink" title="1. 数据库并发处理问题"></a>1. 数据库并发处理问题</h3><p>在多个用户<strong>同时</strong>发起对同一个数据提交修改操作时（先查询，再修改），会出现资源竞争的问题，导致最终修改的数据结果出现异常。</p>
<a id="more"></a>

<p>就拿减库存这个操作来讲， 首先我们取出库存数据， 判断库存数量是否大于0， 如果大于0， 则执行减库存操作， 否则返回库存不足。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入原生sql模块</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TestThread</span>(<span class="params">request</span>):</span></span><br><span class="line"></span><br><span class="line">    res = User.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res.num &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> c:</span><br><span class="line">            c.execute(<span class="string">&#x27;update user set num = num - 1 where id = 1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;库存不足&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在并发场景下， 这段代码很有可能会造成库存减至负数， 造成超卖的问题。 因为当线程A执行<code>update</code>时， 线程B线程可能已经将库存减至0了， 那么线程A再进行更新的话就会造成负数库存。</p>
<p>Python中的线程锁，也是无法解决这个问题的，因为服务可能分布在多台机器上。此时要么采用分布式锁， 要么将锁下沉至数据库中。</p>
<h3 id="2-Mysql中的锁"><a href="#2-Mysql中的锁" class="headerlink" title="2. Mysql中的锁"></a>2. Mysql中的锁</h3><p>如果按锁的粒度划分：表级锁、行级锁、页级锁</p>
<p>如果按锁级别划分：共享锁、排他锁</p>
<ul>
<li><p>共享锁</p>
<p>共享锁又叫读锁，如果事务T对A加上共享锁，则其它事务只能对A再加共享锁，不能加其它锁。</p>
<p>获准共享锁的事务只能读数据，不能写数据。</p>
<p>用法： SELECT … LOCK IN SHARE MODE;</p>
</li>
<li><p>排他锁</p>
<p>排它锁又叫写锁，如果事务T对A加上排它锁，则其它事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。</p>
<p>用法 ： SELECT … FOR UPDATE</p>
</li>
</ul>
<p>在处理并发数据一致性的问题时， 常常会以使用方式来划分， 即乐观锁和悲观锁。</p>
<ul>
<li><p>乐观锁</p>
<p>在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做.</p>
</li>
<li><p>悲观锁</p>
<p>在对数据修改之前, 首先会对该数据加上排它锁, 然后修改数据, 事务结束时释放锁. 如果加锁失败了的话, 说明有其他的事务对该数据进行了加锁操作, 此时可以等待, 也可以抛出异常</p>
</li>
</ul>
<p>用悲观锁来实现减库存操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里写的是sql语句实现悲观锁的简单逻辑</span></span><br><span class="line">begin;</span><br><span class="line">select num <span class="keyword">from</span> user where <span class="built_in">id</span> = <span class="number">1</span> <span class="keyword">for</span> update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">    update user <span class="built_in">set</span> num = num - <span class="number">1</span> where <span class="built_in">id</span> = <span class="number">1</span>;</span><br><span class="line">    commit;</span><br></pre></td></tr></table></figure>

<p>如果使用Django-ORM来做的话：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入原生sql模块</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TestThread</span>(<span class="params">request</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        res = User.objects.select_for_update().get(pk=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res.num &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> c:</span><br><span class="line">                c.execute(<span class="string">&#x27;update user set num = num - 1 where id = 16&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&quot;库存不足&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>搞定！</p>
]]></content>
  </entry>
  <entry>
    <title>Docker-compons搭建redis集群-哨兵模式</title>
    <url>/2020/11/19/Docker-compons%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>上篇讲过为什么要搭建redis集群以及sentinel哨兵模式，今天我们可以使用docker进行搭建，真正的实操一遍</p>
<a id="more"></a>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li><p>新建一个mkdir redis-sentinel文件夹(根目录)，进入根目录再建一个专门存放哨兵的脚本sentinel，cd sentinel</p>
</li>
<li><p>建立sentinel.conf配置文件</p>
<p><img src="https://img-blog.csdnimg.cn/20201207235249512.png"></p>
</li>
</ol>
<p>这一步如果不太清楚的话，可以参照最终配置完成的项目结构，最外层的目录就是最初建立的文件夹</p>
<p>继续，进入setinel.conf配置文件进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster redis-master 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 5000</span><br></pre></td></tr></table></figure>

<p>该配置的意思是，监控主服务器的6379端口并且起两个实例，如果哨兵5s内没有收到主节点的心跳，哨兵就认为主节点宕机了，默认是30秒，如果5秒以上连接不上主库同步，则在5秒后进行选举，对其他的从服务器进行角色转换</p>
<ol start="3">
<li>随后，建立sentinel-entrypoint.sh脚本文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">sed -i &quot;s&#x2F;$SENTINEL_QUORUM&#x2F;$SENTINEL_QUORUM&#x2F;g&quot; &#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span><br><span class="line">sed -i &quot;s&#x2F;$SENTINEL_DOWN_AFTER&#x2F;$SENTINEL_DOWN_AFTER&#x2F;g&quot; &#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span><br><span class="line">sed -i &quot;s&#x2F;$SENTINEL_FAILOVER&#x2F;$SENTINEL_FAILOVER&#x2F;g&quot; &#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span><br><span class="line"></span><br><span class="line">exec docker-entrypoint.sh redis-server &#x2F;etc&#x2F;redis&#x2F;sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>

<p>该脚本文件会对配置文件进行同步，用来启动哨兵</p>
<ol start="4">
<li>建立Dockerfile指定基础镜像，同时拷贝配置文件到镜像内部</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM redis</span><br><span class="line"></span><br><span class="line">EXPOSE 26379</span><br><span class="line">ADD sentinel.conf &#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span><br><span class="line">RUN chown redis:redis &#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span><br><span class="line">COPY sentinel-entrypoint.sh &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">RUN chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;sentinel-entrypoint.sh</span><br><span class="line">ENTRYPOINT [&quot;sentinel-entrypoint.sh&quot;]</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>最后退到项目的根目录，建<code>docker-compose.yml</code> 配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master:</span><br><span class="line">  image: redis</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;6379:6379&quot;</span><br><span class="line">slave1:</span><br><span class="line">  image: redis</span><br><span class="line">  command: redis-server --slaveof redis-master 6379</span><br><span class="line">  links:</span><br><span class="line">    - master:redis-master</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;6380:6379&quot;</span><br><span class="line">slave2:</span><br><span class="line">  image: redis</span><br><span class="line">  command: redis-server --slaveof redis-master 6379</span><br><span class="line">  links:</span><br><span class="line">    - master:redis-master</span><br><span class="line">  ports:</span><br><span class="line">    - &quot;6381:6379&quot;</span><br><span class="line">sentinel1:</span><br><span class="line">  build: sentinel</span><br><span class="line">  environment:</span><br><span class="line">    - SENTINEL_DOWN_AFTER&#x3D;5000</span><br><span class="line">    - SENTINEL_FAILOVER&#x3D;5000    </span><br><span class="line">  links:</span><br><span class="line">    - master:redis-master</span><br><span class="line">    - slave1</span><br><span class="line">sentinel2:</span><br><span class="line">  build: sentinel</span><br><span class="line">  environment:</span><br><span class="line">    - SENTINEL_DOWN_AFTER&#x3D;5000</span><br><span class="line">    - SENTINEL_FAILOVER&#x3D;5000    </span><br><span class="line">  links:</span><br><span class="line">    - master:redis-master</span><br><span class="line">    - slave2</span><br></pre></td></tr></table></figure>

<p>意思是，我们起三台redis服务，分别跑在6379,6380,6381 ，一主两从，并且有两个哨兵实例来监控他们，到这里配置过程就已经全部完成了，接下来看效果</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ol>
<li><p>在项目根目录下，启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up --force-recreate</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201207235146962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>如果希望在后台运行可以加 <code>-d</code> 参数</p>
</li>
<li><p>测试一下，打开三个终端，分别进入redis-cli -p 6379，6380，6381<br>在主服务器6379下，添加一个数据，然后分别get</p>
<p><img src="https://img-blog.csdnimg.cn/20201207235209360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>没有问题，现在我们来测一下哨兵模式是否好用，如果主库由于某种原因宕机了，从库是否能自动切换角色</p>
</li>
<li><p>我们可以手动停止主库的容器进程，来模拟宕机的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop redis-sentinel_master_1</span><br></pre></td></tr></table></figure>

<p>此时主库已经连接不上了，我们进入从库，使用info命令来查看从库的角色</p>
<p><img src="https://img-blog.csdnimg.cn/20201207235229756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>可以看到，6379在停掉服务后已经连接不上了，并且6380本来是从库(slave)角色，现在已经变成主库了(master)了</p>
</li>
</ol>
<p>其实这就是所谓的高负载高可用架构，在使用集群承担高负载的同时，也能进行高可用的容灾机制。</p>
]]></content>
  </entry>
  <entry>
    <title>MySql FIND_IN_SET()函数的使用</title>
    <url>/2020/07/21/FIND-IN-SET-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="MySql-FIND-IN-SET-函数的使用"><a href="#MySql-FIND-IN-SET-函数的使用" class="headerlink" title="MySql FIND_IN_SET()函数的使用"></a>MySql FIND_IN_SET()函数的使用</h2><p>前言：最近在做项目时，涉及到一个场景：我有当前用户的id，想查询它是否在一个list中，list长这样：[1,3,4]，后来又变成了这样：1,3,4，原因我们下面详谈</p>
<a id="more"></a>

<p>原本信誓旦旦的以为将这个list进行处理后就可以用<strong>IN</strong>关键字来查询，后来发现并不行，因此就引入到了<strong>FIND_IN_SET</strong></p>
<h3 id="1-认识find-in-set-函数"><a href="#1-认识find-in-set-函数" class="headerlink" title="1. 认识find_in_set()函数"></a>1. 认识find_in_set()函数</h3><p>语法：FIND_IN_SET(str,strList)</p>
<blockquote>
<p>假如字符串str在由N个子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。 一个字符串列表就是一个由一些被 ‘,’ 符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则FIND_IN_SET() 函数被优化，使用比特计算。 如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。</p>
</blockquote>
<p>相信很多学过mysql的伙伴都觉得自己sql语句已经掌握的炉火纯青了，但是看到这个find_in_set()，你是否又懵了呢，没关系，我们一起来认识一下它。</p>
<p>上面这一段是官方文档给出来的解释，乍一看可能看不明白，今天我们就来剖析一下。</p>
<h3 id="2-基础用法"><a href="#2-基础用法" class="headerlink" title="2. 基础用法"></a>2. 基础用法</h3><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><p><img src="https://img-blog.csdnimg.cn/20201118214336718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>不难看出find_in_set的作用就是查询指定str字符在一组固定的字符串序列中的位置，第一个结果为2，因为<strong>2</strong>在strlist中放在第二个位置，并且起始数是从1开始算起的！，第二个结果显然是0，因为字符集中并不存在5。</p>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p>将find_in_set带入到我们实际的应用中，进行查询整张表的时候，一次返回多条记录的情况</p>
<p>比如说：id是某一个表的主键字段，然后每条记录分别是id等于1，2，3，4，5的时候, 就有点类似in() 的操作了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from work where find_in_set(id,&#39;2,3,4,5,6&#39;);</span><br></pre></td></tr></table></figure>

<p>结果会是这样，如下图</p>
<p> <img src="https://img-blog.csdnimg.cn/20201118214336728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>其实上面的sql语句也等于下面的in</p>
<p><img src="https://img-blog.csdnimg.cn/20201118214336724.png#pic_center"></p>
<h3 id="3-find-in-set-与in-的应用场景以及区别"><a href="#3-find-in-set-与in-的应用场景以及区别" class="headerlink" title="3. find_in_set()与in()的应用场景以及区别"></a>3. find_in_set()与in()的应用场景以及区别</h3><p>刚才我们也看到了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user where find_in_set(id, &#39;2,3,4,5&#39;);</span><br><span class="line">与</span><br><span class="line">select * from user where id in(2,3,4,5);</span><br></pre></td></tr></table></figure>

<p>两条SQL的结果是一样的，但其实还是有一点小区别的。</p>
<p>区别就在于 一个由单引号而另一个没有单引号这里也要针对你所检测的字段是数字类型 还是字符串类型的字段！</p>
<p><strong>对于find_in_set()而言</strong></p>
<p>第二个参数无论是字符串还是数字都必须用单引号括起来，并且字符串列表是用逗号隔开,是一个字符串列表整体要是不这样写 会报语法错误！</p>
<p><strong>对于in()而言</strong></p>
<p>如果是检测的字段如果是数字类型的话就不能用单引号，因为这样会让结果出现偏差</p>
<p><strong>注意：这里有一个小坑，害我不浅，记录一下。</strong></p>
<p>在使用find_in_set()时，第二个参数中的字符集是用逗号隔开的，恰好自己又是个手残党，习惯性的在每个逗号后面多跟了一个不起眼的<strong>空格</strong>，此时它只会查询到字符集中的第一个字符串，后面的所有str都会被忽略，不信你看。</p>
<p><img src="https://img-blog.csdnimg.cn/20201118214336687.png#pic_center"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>如果待查询的条件是<strong>常量(字段)**那就使用</strong>in<strong>，是</strong>变量(不确定值)<strong>则使用</strong>FIND_IN_SET**。</li>
<li>如果使用<strong>IN</strong>和<strong>FIND_IN_SET</strong>都能满足条件，则最好使用<strong>IN</strong>，特别是查询字段为主键时或有索引时。</li>
<li>如果使用<strong>IN</strong>不能满足功能需求，那只能使用<strong>FIND_IN_SET</strong>了。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JWT理解</title>
    <url>/2019/07/15/JWT%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<hr>
<h2 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h2><a id="more"></a>

<h2 id="1-JWT介绍"><a href="#1-JWT介绍" class="headerlink" title="1. JWT介绍"></a>1. JWT介绍</h2><h4 id="1-1-JSON-Web-Token是什么"><a href="#1-1-JSON-Web-Token是什么" class="headerlink" title="1.1 JSON Web Token是什么"></a>1.1 JSON Web Token是什么</h4><p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>
<p>最简单理解：jwt本质就是，<strong>把用户信息通过加密后生成的一个字符串</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JWTd的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;UserName&quot;</span>: <span class="string">&quot;Chongchong&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Role&quot;</span>: <span class="string">&quot;Admin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Expire&quot;</span>: <span class="string">&quot;2018-08-08 20:15:56&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">之后，当用户与服务器通信时，客户在请求中发回JSON对象，服务器仅依赖于这个JSON对象来标识用户。</span><br><span class="line">为了防止用户篡改数据，服务器将在生成对象时签名。</span><br><span class="line">服务器不保存任何会话数据，即服务器变为无状态，使其更容易扩展</span><br></pre></td></tr></table></figure>

<h4 id="1-2-JWT应用场景"><a href="#1-2-JWT应用场景" class="headerlink" title="1.2 JWT应用场景"></a>1.2 JWT应用场景</h4><p><strong>下列场景中使用JSON Web Token是很有用的：</strong></p>
<ul>
<li><strong>Authorization (授权) :</strong> 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</li>
<li><strong>Information Exchange (信息交换) :</strong> 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWTs可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</li>
</ul>
<h2 id="2-JSON-Web-Token的结构是什么样的"><a href="#2-JSON-Web-Token的结构是什么样的" class="headerlink" title="2.  JSON Web Token的结构是什么样的"></a>2.  JSON Web Token的结构是什么样的</h2><img src="E:\Month07\day04\note\JWT结构.png"/>

<p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p>
<ul>
<li><p>header：JWT头部分是一个描述JWT元数据的JSON对象</p>
</li>
<li><p>payload（有效载荷）：七个默认字段+自定义私有字段</p>
</li>
<li><p>Signature（签名）：签名=HMACSHA256( base64UrlEncode(header) + “.” + base64UrlEncode(payload) ,secret)</p>
</li>
</ul>
<p>因此，一个典型的JWT看起来是这个样子的：<code>xxxxx.yyyyy.zzzzz</code></p>
<p>接下来，具体看一下每一部分：</p>
<blockquote>
<p>第一部分：JWT头</p>
</blockquote>
<ul>
<li><code>base64UrlEncode(header)</code> —&gt; 字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line"><span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 1）alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；</span></span><br><span class="line"><span class="comment"># 2）typ属性表示令牌的类型，JWT令牌统一写为JWT。</span></span><br><span class="line"><span class="comment"># 3）最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第二部分：<code>有效载荷</code>   没有敏感数据的用户信息</p>
</blockquote>
<ul>
<li><code>base64UrlEncode(payload)</code> —&gt; 字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认</span></span><br><span class="line">字段供选择。</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">iss：发行人</span></span><br><span class="line"><span class="string">exp：到期时间</span></span><br><span class="line"><span class="string">sub：主题</span></span><br><span class="line"><span class="string">aud：用户</span></span><br><span class="line"><span class="string">nbf：在此之前不可用</span></span><br><span class="line"><span class="string">iat：发布时间</span></span><br><span class="line"><span class="string">jti：JWT ID用于标识该JWT</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、除以上默认字段外，我们还可以自定义私有字段，如下例：</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;chongchong&quot;</span>,</span><br><span class="line"><span class="string">&quot;admin&quot;</span>: true</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 3、注意</span></span><br><span class="line">默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防</span><br><span class="line">止信息泄露。</span><br><span class="line">JSON对象也使用Base64 URL算法转换为字符串保存。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第三部分：<code>签名哈希</code></p>
</blockquote>
<ul>
<li>签名=HMACSHA256<code>( base64UrlEncode(header)</code> + “.” + <code>(base64UrlEncode(payload)</code> ,secret)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</span></span><br><span class="line"><span class="comment"># 2.首先，需要指定一个密码（secret），该密码仅仅为保存在服务器中，并且不能向用户公开。</span></span><br><span class="line"><span class="comment"># 3.然后，使用标头中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名。</span></span><br><span class="line"><span class="comment"># 4.HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret)</span></span><br><span class="line"><span class="comment"># 5.在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用&quot;.&quot;分</span></span><br><span class="line">隔，就构成整个JWT对象。</span><br></pre></td></tr></table></figure>

<h2 id="3-JWT核心"><a href="#3-JWT核心" class="headerlink" title="3. JWT核心"></a>3. JWT核心</h2><ul>
<li><ol>
<li>给用户颁发的token值相当于一把锁，服务器端的秘钥相当于一把钥匙</li>
</ol>
</li>
<li><ol start="2">
<li>每次客户端请求都会携带这把锁，服务器端用秘钥去开这把锁，若果无法打开就证明是伪造的</li>
</ol>
</li>
</ul>
<h2 id="4-JWT特点分析"><a href="#4-JWT特点分析" class="headerlink" title="4. JWT特点分析"></a>4. JWT特点分析</h2><ul>
<li><ol>
<li> JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权 限，一旦JWT签发，在有效期内将会一直有效。</li>
</ol>
</li>
<li><ol start="2">
<li>JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。</li>
</ol>
</li>
<li><ol start="3">
<li>为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行 传输。</li>
</ol>
</li>
<li><ol start="4">
<li>JWT不仅可用于认证，还可用于信息交换，善用JWT有助于减少服务器请求数据库的次数。</li>
</ol>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MongoDB命令</title>
    <url>/2021/03/18/MongoDB%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h5 id="MongoDB命令："><a href="#MongoDB命令：" class="headerlink" title="MongoDB命令："></a>MongoDB命令：</h5><p>1.查看数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure>

<p>2.创建并使用数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 数据库名</span><br></pre></td></tr></table></figure>

<p>3.查看当前工作的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure>

<p>4.创建集合并插入一条数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.表名.insert(&#123;&#39;name&#39;:&#39;辣条&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>5.查看所有表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables</span><br></pre></td></tr></table></figure>

<p>6.查询表中所有数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.表名.find()</span><br></pre></td></tr></table></figure>

<p>7.删除表操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.表名.drop()</span><br></pre></td></tr></table></figure>

<p>8.删除数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>MySQL8.0和redis允许外部访问</title>
    <url>/2019/07/23/MySQL8-0%E5%92%8Credis%E5%85%81%E8%AE%B8%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h3 id="数据库允许外部访问"><a href="#数据库允许外部访问" class="headerlink" title="数据库允许外部访问"></a>数据库允许外部访问</h3><p>默认情况下，MySQL只允许本地登录，如果要开启远程连接，让外部进行访问，则需要进行配置。</p>
<a id="more"></a>

<ol>
<li><p>登陆MySQL。</p>
</li>
<li><p>执行以下命令，进入mysql库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure>

<p>注意：这里的mysql指的是MySQL自带的mysql库，并不是具体的某个数据库。</p>
</li>
<li><p>更新域属性，’%’表示允许外部访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set host&#x3D;&#39;%&#39; where user &#x3D;&#39;root&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行授权语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>按顺序执行完上面的代码，外部就可以通过账户密码访问了。</p>
<h3 id="Redis外部访问设置"><a href="#Redis外部访问设置" class="headerlink" title="Redis外部访问设置"></a>Redis外部访问设置</h3><ol>
<li><p>打开服务，查看redis具体使用的配置文件</p>
<p><img src="https://img-blog.csdnimg.cn/2020112323450371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
</li>
<li><p>进入Redis目录并打开对应的配置文件，为什么要先查看是哪个配置，就是因为Redis目录下是有两个config配置文件，不确定系统服务中具体用的哪个，所以提前看一眼。</p>
<p><img src="https://img-blog.csdnimg.cn/2020112323454457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>将56行的bind注释掉或者改为0.0.0.0</p>
<p>禁用保护模式</p>
<p>protected-mode改为no</p>
</li>
<li><p>重启服务，通过局域网ip或者外网就可以访问了。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>WebSocket机制</title>
    <url>/2020/06/12/WebSocket%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><h5 id="WebSocket-是一种网络通信协议"><a href="#WebSocket-是一种网络通信协议" class="headerlink" title="WebSocket 是一种网络通信协议"></a><a href="http://websocket.org/">WebSocket</a> 是一种网络通信协议</h5><h4 id="1-了解WebSocket？"><a href="#1-了解WebSocket？" class="headerlink" title="1. 了解WebSocket？"></a>1. 了解WebSocket？</h4><p>初次接触WebSocket的人，都会问同样的问题：我们已经有了HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p>
<a id="more"></a>

<p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p>
<p>举个栗子：股票系统，我们在股票中自选某个股票，我们很关心它的价格起伏，我们不可能时时刻刻盯着股价来看，这个时候就在想，如果交易所可以自动推送股票的价格该多好，如果采用我们平时HTTP协议，只能是客户端向服务器发起请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。</p>
<p>这种单向请求的特点，客户端想要频繁的获取数据就非常麻烦，我们只能使用<strong>轮询</strong>，每隔一段时间，就发出一个请求，获取服务器数据。</p>
<p>轮询的效率低，非常浪费资源，因此，就诞生了WebSocket</p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li><p>建立在 TCP 协议之上，服务器端的实现比较容易。</p>
</li>
<li><p>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p>
</li>
<li><p>数据格式比较轻量，性能开销小，通信高效。</p>
</li>
<li><p>没有同源限制，客户端可以与任意服务器通信</p>
</li>
<li><p>协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws:<span class="comment">//localhost:8000/websocketlink/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-django2-0-4-vue简单示例"><a href="#3-django2-0-4-vue简单示例" class="headerlink" title="3. django2.0.4+vue简单示例"></a>3. django2.0.4+vue简单示例</h4><h5 id="3-1服务端的视图函数"><a href="#3-1服务端的视图函数" class="headerlink" title="3.1服务端的视图函数"></a>3.1服务端的视图函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入dwebsocket的库</span></span><br><span class="line"><span class="keyword">from</span> dwebsocket.decorators <span class="keyword">import</span> accept_websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端列表</span></span><br><span class="line">clients = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">websocket_link</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 判断是否是websocket请求</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket():</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 客户端唯一标志</span></span><br><span class="line">        user_id = <span class="built_in">str</span>(uuid.uuid1())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		</span><br><span class="line">            message = request.websocket.wait()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> message:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># print(&#x27;websocket链接成功&#x27; + str(message))</span></span><br><span class="line">                clients[uid] = request.websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送消息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendmessage</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 获取消息</span></span><br><span class="line">    msg = request.GET.get(<span class="string">&#x27;msg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> uid <span class="keyword">in</span> clients:</span><br><span class="line">        clients[uid].send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;OK&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-2-客户端的API"><a href="#3-2-客户端的API" class="headerlink" title="3.2 客户端的API"></a>3.2 客户端的API</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面挂载时调用</span></span><br><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断浏览器是否支持websocket</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="string">&quot;WebSocket&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;支持&quot;</span>)</span><br><span class="line">      <span class="comment">// 生成websocket链接</span></span><br><span class="line">      <span class="keyword">var</span> uid = <span class="built_in">this</span>.token;</span><br><span class="line">      <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8000/websocketlink/&quot;</span>);</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 发送链接请求</span></span><br><span class="line">      ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ws.send(uid)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 发送消息</span></span><br><span class="line">      ws.onmessage = <span class="function">(<span class="params">evt</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 将获取信息打印</span></span><br><span class="line">        <span class="keyword">var</span> received_msg = evt.data;</span><br><span class="line">        alert(received_msg)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 捕获断开链接</span></span><br><span class="line">      ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;链接已经关闭&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>OK，我们来简单测一下</p>
<p>首先访问我们刚刚写好的推送消息视图函数</p>
<p><img src="https://img-blog.csdnimg.cn/20201109235854323.png#pic_center"></p>
<p>没有问题，此时打开vue端连接了websocket的任何一个组件</p>
<p><img src="https://img-blog.csdnimg.cn/20201109235854301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>此时可以看到，客户端自动弹出对话框，代表websocket示例成功！</p>
]]></content>
  </entry>
  <entry>
    <title>Webhook机制</title>
    <url>/2020/06/08/Webhook%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="WebHook的理解"><a href="#WebHook的理解" class="headerlink" title="WebHook的理解"></a>WebHook的理解</h2><p>前言：</p>
<p>我们在前面的文章中就已经详细的介绍过工作流的流程，可以想想，在审批人审批完任务后，如果没有消息推送，申请人就不会第一时间知道申请流程具体到哪一步，用户总不可能一直盯着平台刷页</p>
<a id="more"></a>

<p>面，所以我们需要一个智能消息推送的功能。为了及时通知，此时就产生了WebHook这种概念，其实就是为了更好地去通知调用的结果。</p>
<h4 id="Webhook概述"><a href="#Webhook概述" class="headerlink" title="Webhook概述"></a>Webhook概述</h4><ul>
<li>Webhook是一个API概念，并且变得越来越流行。我们能用事件描述的事物越多，webhook的作用范围也就越大。Webhook作为一个轻量的事件处理应用，正变得越来越有用。</li>
<li>准确的说webhook是一种web回调或者http的push API，是向APP或者其他应用提供实时信息的一种方式。Webhook在数据产生时立即发送数据，也就是你能实时收到数据。这一种不同于典型的API，需要用了实时性需要足够快的轮询。这无论是对生产还是对消费者都是高效的，唯一的缺点是初始建立困难。</li>
<li>Webhook有时也被称为反向API，因为他提供了API规则，你需要设计要使用的API。Webhook将向你的应用发起http请求，典型的是post请求，应用程序由请求驱动。</li>
<li>Webhook模式的主要优点是，当你的应用在等待变化时，无需周期性地调用API</li>
</ul>
<h4 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h4><p>常用于异步编程中，如：高安全的支付、OAuth登录（微博、微信）、资源同步、资源创建于更新、耗时较长。</p>
<p>场景：</p>
<p>你需要向视频处理服务器上传一个视频、你需要获得视频处理后的结果，然而视频处理服务器上视频很多，在排队进行处理，你不能立刻获取到视频的处理结果，此时你可以设计一个hook url，当视频处理完成后，视频处理服务器自动向你的hook url发送请求，告诉你视频已经处理完毕</p>
<p><img src="https://img-blog.csdnimg.cn/20201203150626581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
]]></content>
  </entry>
  <entry>
    <title>admin超级管理员</title>
    <url>/2021/05/08/admin%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-首先的话"><a href="#1-首先的话" class="headerlink" title="1.首先的话"></a>1.首先的话</h2><p>需要配置admin里面的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from APP名.models import *</span><br><span class="line"></span><br><span class="line">admin.site.register(表名)</span><br></pre></td></tr></table></figure>



<h2 id="2-配置路由URL"><a href="#2-配置路由URL" class="headerlink" title="2.配置路由URL"></a>2.配置路由URL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.conf.urls import url</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">	url(r&#39;^admin&#x2F;&#39;,admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="3-运行命令"><a href="#3-运行命令" class="headerlink" title="3.运行命令"></a>3.运行命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>ant组件</title>
    <url>/2021/03/01/ant%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>Ant参考地址：</p>
<p>  · <a href="https://www.antdv.com/components/icon-cn/">https://www.antdv.com/components/icon-cn/</a></p>
<p>1.使用组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save ant-design-vue</span><br></pre></td></tr></table></figure>



<p>main.js引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ant from &#39;ant-design-vue&#39;</span><br><span class="line">import &#39;ant-design-vue&#x2F;dist&#x2F;antd.css&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(ant)</span><br></pre></td></tr></table></figure>



<h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><p>分为五种： 主按钮、次按钮、虚线按钮、危  险按钮和链接按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">属性：disabled:按钮失效状态      ghost:使按钮背景透明     size:设置按钮大小     type:设置按钮类型（可选值为 primary dashed danger link 或者不设）  </span><br></pre></td></tr></table></figure>

<p>主按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a-button type&#x3D;&#39;primary&#39;&gt; &lt;&#x2F;a-button&gt;</span><br></pre></td></tr></table></figure>

<p>次按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a-button&gt; &lt;&#x2F;a-button&gt;</span><br></pre></td></tr></table></figure>

<p>虚线按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a-button type&#x3D;&#39;dashed&#39;&gt; &lt;&#x2F;a-button&gt;</span><br></pre></td></tr></table></figure>

<p>危险按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a-button type&#x3D;&#39;danger&#39;&gt; &lt;&#x2F;a-button&gt;</span><br></pre></td></tr></table></figure>

<p>链接按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a-button type&#x3D;&quot;link&quot;&gt; &lt;&#x2F;a-button&gt;</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>ant组件</tag>
      </tags>
  </entry>
  <entry>
    <title>celery介绍</title>
    <url>/2019/11/20/celery%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="1-celery介绍"><a href="#1-celery介绍" class="headerlink" title="1. celery介绍"></a>1. celery介绍</h2><h4 id="1-1-celery应用举例"><a href="#1-1-celery应用举例" class="headerlink" title="1.1 celery应用举例"></a>1.1 celery应用举例</h4><ul>
<li>Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理，如果你的业务场景中需要用到异步任务，就可以考虑使用celery</li>
</ul>
<a id="more"></a>

<ul>
<li>你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回 一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果， 在任务执行ing进行时，你可以继续做其它的事情</li>
<li>Celery 在执行任务时需要通过一个消息中间件来接收和发送任务消息，以及存储任务结果， 一般使用rabbitMQ or Redis</li>
</ul>
<h4 id="1-2-celery优点"><a href="#1-2-celery优点" class="headerlink" title="1.2 celery优点"></a>1.2 celery优点</h4><ul>
<li>简单：一旦熟悉了celery的工作流程后，配置和使用还是比较简单的</li>
<li>高可用：当任务执行失败或执行过程中发生连接中断，celery会自动尝试重新执行任务</li>
<li>快速：一个单进程的celery每分钟可处理上百万个任务</li>
<li>灵活：几乎celery的各个组件都可以被扩展及自定制</li>
</ul>
<h4 id="1-3-celery特性"><a href="#1-3-celery特性" class="headerlink" title="1.3 celery特性"></a>1.3 celery特性</h4><ul>
<li>方便查看定时任务的执行情况，如：是否成功，当前状态，执行任务花费的时间等</li>
<li>可选 多进程，Eventlet 和 Gevent 三种模型并发执行</li>
<li>celery是语言无关的，它提供了python等常见语言的接口支持</li>
</ul>
<h2 id="2-celery组件"><a href="#2-celery组件" class="headerlink" title="2.celery组件"></a>2.celery组件</h2><h4 id="2-1-celery扮演生产者和消费者的角色"><a href="#2-1-celery扮演生产者和消费者的角色" class="headerlink" title="2.1 celery扮演生产者和消费者的角色"></a>2.1 celery扮演生产者和消费者的角色</h4><ul>
<li><strong>Celery Beat :</strong> 任务调度器. Beat 进程会读取配置文件的内容, 周期性的将配置中到期需要执行的任务发送给任务队列.</li>
<li><strong>Celery Worker :</strong> 执行任务的消费者, 通常会在多台服务器运行多个消费者, 提高运行效率.</li>
<li><strong>Broker :</strong> 消息代理, 队列本身. 也称为消息中间件. 接受任务生产者发送过来的任务消息, 存进队列再按序分发给任务消费方(通常是消息队列或者数据库).</li>
<li><strong>Producer :</strong> 任务生产者. 调用 Celery API , 函数或者装饰器, 而产生任务并交给任务队列处理的都是任务生产者.</li>
<li><strong>Result Backend :</strong> 任务处理完成之后保存状态信息和结果, 以供查询.</li>
</ul>
<h4 id="2-2-celery架构图"><a href="#2-2-celery架构图" class="headerlink" title="2.2 celery架构图"></a>2.2 celery架构图</h4><p><img src="https://img-blog.csdnimg.cn/20201207234930510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h4 id="2-3-产生任务的方式"><a href="#2-3-产生任务的方式" class="headerlink" title="2.3 产生任务的方式"></a>2.3 产生任务的方式</h4><ol>
<li>发布者发布任务(WEB 应用)</li>
<li>任务调度按期发布任务(定时任务)</li>
</ol>
<h4 id="2-4-celery-依赖三个库-这三个库-都由-Celery-的开发者开发和维护"><a href="#2-4-celery-依赖三个库-这三个库-都由-Celery-的开发者开发和维护" class="headerlink" title="2.4 celery 依赖三个库: 这三个库, 都由 Celery 的开发者开发和维护."></a>2.4 celery 依赖三个库: 这三个库, 都由 Celery 的开发者开发和维护.</h4><ol>
<li><strong>billiard</strong> ：基于 Python2.7 的 multisuprocessing 而改进的库, 主要用来提高性能和稳定性.</li>
<li><strong>librabbitmp</strong>：C语言实现的Python客户端</li>
<li><strong>kombu</strong>：Celery自带的用来收发消息的库，提供了符合 Python 语言习惯的, 使用 AMQP 协议的高级接口.</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>自学测试day01-02</title>
    <url>/2021/09/22/day01-02/</url>
    <content><![CDATA[<h1 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h1><h3 id="软件的定义"><a href="#软件的定义" class="headerlink" title="软件的定义"></a>软件的定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是一系列按照特定顺序组织的计算机数据和指令的集合</span><br></pre></td></tr></table></figure>



<h3 id="软件开发模式"><a href="#软件开发模式" class="headerlink" title="软件开发模式"></a>软件开发模式</h3><h5 id="分为：瀑布模型、快速原型模型、螺旋模型、迭代模型、增量模型、敏捷开发模式"><a href="#分为：瀑布模型、快速原型模型、螺旋模型、迭代模型、增量模型、敏捷开发模式" class="headerlink" title="分为：瀑布模型、快速原型模型、螺旋模型、迭代模型、增量模型、敏捷开发模式"></a>分为：瀑布模型、快速原型模型、螺旋模型、迭代模型、增量模型、敏捷开发模式</h5><h5 id="瀑布模型："><a href="#瀑布模型：" class="headerlink" title="瀑布模型："></a>瀑布模型：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">瀑布模型：将软件生命周期的各项活动规定为按固定顺序而连接的若干阶段工作</span><br></pre></td></tr></table></figure>



<h5 id="快速原型模型："><a href="#快速原型模型：" class="headerlink" title="快速原型模型："></a>快速原型模型：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原型系统的内部结构并不重要，重要的是必须迅速建立原型，随之迅速修改原型，以反映客户的需求</span><br></pre></td></tr></table></figure>



<h5 id="螺旋模型："><a href="#螺旋模型：" class="headerlink" title="螺旋模型："></a>螺旋模型：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">螺旋模型：沿着螺线进行若干次迭代，分为：</span><br><span class="line">	1.制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件</span><br><span class="line">	2.风险分析：分析评估所选方案，考虑如何识别和消除风险</span><br><span class="line">	3.实施工程：实施软件开发和验证</span><br><span class="line">	4.客户评估：评价开发工作，提出修正建议，指定下一步计划</span><br><span class="line">限制条件：</span><br><span class="line">    1.适应于内部的大规模软件开发。</span><br><span class="line">    2.如果执行风险分析将大大影响项目的利润，那么进行风险分析毫无意义，因此，螺旋模型只适合于大规模软件项目。 </span><br></pre></td></tr></table></figure>

<p>螺旋模型 = 瀑布模型 + 快速原型模型</p>
<h5 id="迭代模型："><a href="#迭代模型：" class="headerlink" title="迭代模型："></a>迭代模型：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">迭代模型：是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。</span><br></pre></td></tr></table></figure>



<h5 id="增量模型："><a href="#增量模型：" class="headerlink" title="增量模型："></a>增量模型：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增量模型：整个产品被分解成若干个构件，开发人员逐个构件地交付产品。</span><br></pre></td></tr></table></figure>



<h5 id="敏捷开发模式："><a href="#敏捷开发模式：" class="headerlink" title="敏捷开发模式："></a>敏捷开发模式：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">敏捷开发模式：是一种以人为核心、迭代、循序渐进的开发方法。就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，</span><br></pre></td></tr></table></figure>



<h3 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有质量要求的,软件质量关系着软件使用程度与使用寿命，它除了满足客户的显式需求之外,往往还满足了客户隐式需求</span><br></pre></td></tr></table></figure>



<h3 id="软件分类"><a href="#软件分类" class="headerlink" title="软件分类"></a>软件分类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据应用场景分类：工具类软件、游戏型软件、媒体型软件、电商型软件等</span><br><span class="line">根据软件架构分类：单机版软件、分布式软件</span><br><span class="line">单机版软件： office、红警等</span><br><span class="line">分布式软件：</span><br><span class="line">	C&#x2F;S架构软件：客户端需安装专门软件，如QQ 微信等</span><br><span class="line">	B&#x2F;S架构软件：客户端为浏览器 ，如百度、hao123等</span><br></pre></td></tr></table></figure>



<h3 id="软件开发生态"><a href="#软件开发生态" class="headerlink" title="软件开发生态"></a>软件开发生态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">软件开发生态系统目前最流行最常见的有App、微信小程序、公众号、前端和后台</span><br></pre></td></tr></table></figure>



<h1 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h1><h2 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开发流程分为六个阶段：</span><br><span class="line">	项目启动阶段，需求阶段，设计阶段，开发阶段，测试阶段，项目上线</span><br><span class="line">项目启动：</span><br><span class="line">	    产品总监&#x2F;产品经理 需求调研  --》《需求调研》文档</span><br><span class="line">		产品经理 --》梳理业务</span><br><span class="line">需求阶段：</span><br><span class="line">		产品经理 --》最简单接近成品的产品原型，需求文档，需求评审，</span><br><span class="line">		研发经理 --》根据需求 明确《产品里程碑》，根据项目里程表，完成《产品开发计划》，明确详细阶段的时间点，最后根据开发计划，进行《项目任务分解》，完成项目的分工。</span><br><span class="line">设计阶段：</span><br><span class="line">		UI设计师 --》 产品效果图，UI设计规范，标注图，切图</span><br><span class="line">开发阶段：</span><br><span class="line">		开发工程师--写代码，技术文档</span><br><span class="line">测试阶段:</span><br><span class="line">		测试工程师--》 测试用例（Test case）明确测试方案，测试结果报告，用户手册，系统操作手册</span><br><span class="line"></span><br><span class="line">		</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>自学测试day05</title>
    <url>/2021/09/23/day05/</url>
    <content><![CDATA[<h1 id="day05"><a href="#day05" class="headerlink" title="day05"></a>day05</h1><h2 id="1-测试用例（test-case）"><a href="#1-测试用例（test-case）" class="headerlink" title="1.测试用例（test case）"></a>1.测试用例（test case）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设计测试用例的方法：等价类划分法，边界值分析法，场景法，正交实验法，错误推测，因果图，判定表</span><br></pre></td></tr></table></figure>



<h3 id="1-1场景法定义"><a href="#1-1场景法定义" class="headerlink" title="1.1场景法定义"></a>1.1场景法定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为某个业务目标，而编制的一组由测试输入，执行条件以及预期结果组成的案例</span><br></pre></td></tr></table></figure>

<h3 id="1-2用例的核心元素（16个）"><a href="#1-2用例的核心元素（16个）" class="headerlink" title="1.2用例的核心元素（16个）"></a>1.2用例的核心元素（16个）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.用例编号:  产品型号-文件类型-版本号-序号</span><br><span class="line">2.所属模块：	</span><br><span class="line">3.用例标题：一看到标题就能大概猜到这条用例在测试什么(谁在什么情况下 去做什么 最后结果是什么)</span><br><span class="line">4.优先级：	</span><br><span class="line">5.前置条件：	在做这个测试之前必须要先做的事情（查看他点赞的东西，前提必须先登录他的号）</span><br><span class="line">6.操作步骤：</span><br><span class="line">7.测试数据：</span><br><span class="line">8.预期结果：	有前提条件&#x2F;操作步骤&#x2F;测试数据，预期结果就知道了，预期结果是应该得出的正确结果</span><br><span class="line">9.实际结果：	测试后得到的结果，可能与预期结果不同</span><br><span class="line">10.了解内容： 通过否</span><br><span class="line">11.bugID:</span><br><span class="line">12.编写人员： </span><br><span class="line">13.编写时间：</span><br><span class="line">14.测试人员：</span><br><span class="line">15.测试时间：</span><br><span class="line">16.备注：</span><br></pre></td></tr></table></figure>

<h3 id="1-3提取测试点"><a href="#1-3提取测试点" class="headerlink" title="1.3提取测试点"></a>1.3提取测试点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个一个需要分析测试的地方</span><br><span class="line">一个测试点有可能会有多条测试用例，一个用例只测试一个测试点</span><br><span class="line">每一个和用户交互的地方都是测试点</span><br><span class="line">可以画业务流程图，流程图的每一个步骤都是测试点</span><br></pre></td></tr></table></figure>

<h3 id="1-4等价类划分法"><a href="#1-4等价类划分法" class="headerlink" title="1.4等价类划分法"></a>1.4等价类划分法</h3><h4 id="1-4-1定义"><a href="#1-4-1定义" class="headerlink" title="1.4.1定义"></a>1.4.1定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把可能输入的数据分为若干个区域，然后从每个区域中取少量有代表性的数据</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2分类"><a href="#1-4-2分类" class="headerlink" title="1.4.2分类"></a>1.4.2分类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有效等价类： 符合《需求规格说明书》，输入合理的数据集合</span><br><span class="line">无效等价类：不符合《需求规格说明书》，输入不合理的数据集合</span><br></pre></td></tr></table></figure>

<h4 id="1-4-3类型"><a href="#1-4-3类型" class="headerlink" title="1.4.3类型"></a>1.4.3类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">取值范围型：学生成绩0-100</span><br><span class="line">恒等类型：只有一个结果是正确的，其他</span><br><span class="line">布尔值型： true false</span><br><span class="line">枚举类型： (&#39;&#39;,&#39;&#39;)</span><br><span class="line">规则类型： 给定要求</span><br><span class="line">字符类型：中文、英文、特殊字符、空格、数字</span><br></pre></td></tr></table></figure>

<h4 id="1-4-4案例"><a href="#1-4-4案例" class="headerlink" title="1.4.4案例"></a>1.4.4案例</h4><h5 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a>案例一：</h5><p><img src="/case/day05_img02.jpg"></p>
<p>划分等价类并编号,下表为等价类划分的结果</p>
<p><img src="/case/day05_img03.jpg"></p>
<h5 id="案例二："><a href="#案例二：" class="headerlink" title="案例二："></a>案例二：</h5><p><img src="/case/day05_img04.jpg"></p>
<h3 id="1-5边界值分析法"><a href="#1-5边界值分析法" class="headerlink" title="1.5边界值分析法"></a>1.5边界值分析法</h3><h4 id="1-5-1定义"><a href="#1-5-1定义" class="headerlink" title="1.5.1定义"></a>1.5.1定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">边界值分析是取稍高于或稍低于边界的一些数据进行测试。</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2原因"><a href="#1-5-2原因" class="headerlink" title="1.5.2原因"></a>1.5.2原因</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序开发循环体时的取数可能会因为&lt;,&lt;&#x3D;搞错。</span><br><span class="line">8到10岁（含8岁和10岁）：8&lt;&#x3D;age&lt;10 	[8,10]</span><br><span class="line">8到10岁（不含8岁和10岁）：8&lt;age&lt;&#x3D;10	(8,10]	左开右闭</span><br><span class="line">8到10岁（含8岁和不含10岁）：8&lt;&#x3D;age&lt;10	[8,10)	左闭右开</span><br><span class="line">8到10岁（不含8岁和不含10岁）：8&lt;age&lt;10 (8,10)</span><br><span class="line"></span><br><span class="line">[]是闭 ()是开</span><br><span class="line">开区间：不包含等于的区域</span><br><span class="line">闭区间：包含等于的区域</span><br><span class="line"></span><br><span class="line">上点：边界上的点8,10</span><br><span class="line">离点：离上点最近的点 （开内闭外）</span><br><span class="line">内点：域内的点9</span><br></pre></td></tr></table></figure>



<h4 id="1-5-3确定边界值的方法"><a href="#1-5-3确定边界值的方法" class="headerlink" title="1.5.3确定边界值的方法"></a>1.5.3确定边界值的方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上点：左边是什么值就是左上点，右边是什么值就是右上点，不考虑开闭区间 </span><br><span class="line">离点：离上点最近的点，（开内闭外）</span><br><span class="line">内点：域内的任意点就是内点</span><br></pre></td></tr></table></figure>







<p>1.（1990-1-1 ，今天] 上点内点，离点，有效等价类和无效等价类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左上点：1990-1-1</span><br><span class="line">右上点：今天</span><br><span class="line">左离点：1990-1-2</span><br><span class="line">右离点：今天+1天</span><br><span class="line">内点： 1990-1-1&lt;内点&lt;&#x3D;今天</span><br><span class="line"></span><br><span class="line">有效等价类：1990-1-1&lt;有效等价类&lt;&#x3D;今天</span><br><span class="line">无效等价类：无效等价类&#x3D;&lt;1990-1-1 ， 今天&lt;无效等价类</span><br></pre></td></tr></table></figure>

<p>2.边界值讲义案例二</p>
<p><img src="/case/day05_img04.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：</span><br><span class="line">1.姓名：</span><br><span class="line">	有效等价类： 1&lt;&#x3D; 有效&lt;&#x3D;20（汉字）</span><br><span class="line">	无效等价类： 20&lt;无效，无效&lt;1，非汉字，空值，空格，特殊字符    </span><br><span class="line">	(边界值分析)：分析出为[1,20]</span><br><span class="line">		上点：1,20</span><br><span class="line">		离点：0,21</span><br><span class="line">		内点：1&lt;&#x3D;内点&lt;&#x3D;20</span><br><span class="line"></span><br><span class="line">2.身份证号：</span><br><span class="line">	有效等价类：15,18，14位纯数字+X，17位纯数字+X</span><br><span class="line">	无效等价类：：0-14，19-+∞，特殊字符，空值，空格，纯英文字母</span><br><span class="line">	</span><br><span class="line">3.籍贯：</span><br><span class="line">	有效等价类：1&lt;&#x3D;有效&lt;&#x3D;50,(汉字)</span><br><span class="line">	无效等价类：1&gt;无效，50&lt;无效,空值,特殊符号,空格,英文,数字,中+英,中+数,中+英+数,英+数 </span><br><span class="line">	(边界值分析)：分析出为[1,50]</span><br><span class="line">		上点：1,50</span><br><span class="line">		离点：0,51</span><br><span class="line">		内点：1&lt;&#x3D;内点&lt;&#x3D;50</span><br><span class="line"></span><br><span class="line">4.出生年月：</span><br><span class="line">	有效等价类：1900-1-1&lt;&#x3D;有效&lt;&#x3D;2019-1-1</span><br><span class="line">	无效等价类：1900-1-1&gt;无效 ，2019-1-1&lt;无效</span><br><span class="line">	(边界值分析)：分析出为[1900-1-1,2019-1-1]</span><br><span class="line">		上点：1900-1-1,2019-1-1</span><br><span class="line">		离点：1899-12-31,2019-1-2</span><br><span class="line">		内点：1900-1-1&lt;&#x3D;内点&lt;&#x3D;2019-1-1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二步：</span><br><span class="line">1.身份证正面：</span><br><span class="line">	有效等价类：5M以内，结尾为jpg,png</span><br><span class="line">	无效等价类：1). 5M以外，结尾为jpg,png</span><br><span class="line">			  2). 5M以内，结尾不为Jpg,png</span><br><span class="line">			  3). 5M以外，结尾不为jpg,png</span><br><span class="line">2.身份证反面：</span><br><span class="line">	有效等价类：5M以内，结尾为jpg,png</span><br><span class="line">	无效等价类：1). 5M以外，结尾为jpg,png</span><br><span class="line">			  2). 5M以内，结尾不为Jpg,png</span><br><span class="line">			  3). 5M以外，结尾不为jpg,png</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第三步：</span><br><span class="line">1.银行卡号</span><br><span class="line">    有效等价类：16位纯数字</span><br><span class="line">    无效等价类：0-15， 大于16，特殊字符，空值，空格，英文字符</span><br><span class="line"></span><br><span class="line">2.开户人姓名</span><br><span class="line">    有效等价类：1-20个汉字（20个汉字以内，默认包含20，非空大于0，从1开始到20）</span><br><span class="line">    无效等价类：大于20个汉字，非汉字，空值，空格，特殊字符</span><br><span class="line"></span><br><span class="line">3.支付金额</span><br><span class="line">    有效等价类：0.01元--全部存款（默认以“元”为单位）</span><br><span class="line">    无效等价类：空值，小于0.01元，英文字母，特殊符号，汉字</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>自学测试day03-04</title>
    <url>/2021/09/22/day03-04/</url>
    <content><![CDATA[<h1 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h1><h3 id="1-软件缺陷定义"><a href="#1-软件缺陷定义" class="headerlink" title="1.软件缺陷定义"></a>1.软件缺陷定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">俗称bug，</span><br><span class="line">1.软件未达到产品说明书 （没有 必须需要的功能）</span><br><span class="line">2.出现产品说明书指明不会出现的错误 （说明书记载的错误）</span><br><span class="line">3.功能超出产品说明书指明的范围	（添加说明书以为的功能）</span><br><span class="line">4.未达到产品说明书虽未指出但应该达到的目标	（说明书内没记载的错误）</span><br><span class="line">5.难以理解、不易使用，用户认为不好的	（用户认为不需要的功能）</span><br></pre></td></tr></table></figure>



<h3 id="2-软件缺陷产生的原因"><a href="#2-软件缺陷产生的原因" class="headerlink" title="2.软件缺陷产生的原因"></a>2.软件缺陷产生的原因</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.编码问题</span><br><span class="line">2.软件结构复杂</span><br><span class="line">3.项目期限短</span><br><span class="line">4.使用新技术</span><br><span class="line">5.频繁更新需求</span><br></pre></td></tr></table></figure>



<h3 id="3-软件缺陷分类"><a href="#3-软件缺陷分类" class="headerlink" title="3.软件缺陷分类"></a>3.软件缺陷分类</h3><p><img src="/case/img01.jpg"></p>
<h3 id="4-常用软件缺陷管理工具"><a href="#4-常用软件缺陷管理工具" class="headerlink" title="4.常用软件缺陷管理工具"></a>4.常用软件缺陷管理工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">禅道，jira，gitee</span><br></pre></td></tr></table></figure>



<h3 id="5-软件测试简介"><a href="#5-软件测试简介" class="headerlink" title="5.软件测试简介"></a>5.软件测试简介</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过人工或自动化的方式来验证软件的实际结果与用户需求是否一致的过程</span><br></pre></td></tr></table></figure>



<h3 id="6-软件测试的目的"><a href="#6-软件测试的目的" class="headerlink" title="6.软件测试的目的"></a>6.软件测试的目的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.以最少的人力、物力和时间找出软件中潜在的各种错误和bug，避免软件发布后带来的商业风险</span><br><span class="line">2.利用测试过程中得到的测试结果和测试信息，作为后续项目开发和测试过程改进的重要输入，避免在将来的项目开发中和测试中重复同样的错误</span><br><span class="line">3.采用更加高效的测试管理手段，提高软件测试的效率和软件产品的质量</span><br></pre></td></tr></table></figure>



<h3 id="7-软件测试与开发的关系"><a href="#7-软件测试与开发的关系" class="headerlink" title="7.软件测试与开发的关系"></a>7.软件测试与开发的关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开发：是生产制造软件产品</span><br><span class="line">测试：是效验产品是否合格</span><br><span class="line">两者密切合作才能保证软件产品的质量</span><br></pre></td></tr></table></figure>



<h3 id="8-软件测试模型"><a href="#8-软件测试模型" class="headerlink" title="8.软件测试模型"></a>8.软件测试模型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V模型 和 W模型</span><br></pre></td></tr></table></figure>

<h4 id="V模型："><a href="#V模型：" class="headerlink" title="V模型："></a>V模型：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">明确地标明了测试过程中存在级别，一步一步来</span><br></pre></td></tr></table></figure>

<p><img src="/case/img06.jpg"></p>
<h4 id="W模型："><a href="#W模型：" class="headerlink" title="W模型："></a>W模型：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试与开发是同步进行的，从而有利于尽早地发现问题</span><br></pre></td></tr></table></figure>

<p><img src="/case/img07.jpg"></p>
<h3 id="9-测试流程"><a href="#9-测试流程" class="headerlink" title="9.测试流程"></a>9.测试流程</h3><p><img src="/case/img08.jpg"></p>
<h3 id="10-软件测试原则"><a href="#10-软件测试原则" class="headerlink" title="10.软件测试原则"></a>10.软件测试原则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.测试显示软件存在Bug	（测试只能证明软件中存在bug，但不能证明软件中不存在Bug）</span><br><span class="line">2.穷尽测试是不可能的	（复杂度高，想做到完全性的测试是不可能的）</span><br><span class="line">3.测试尽早介入	（bug发现越早，修复的成本就越小）</span><br><span class="line">4.Bug集群性(2&#x2F;8原则)		（小部分模块包含大部分Bug）</span><br><span class="line">5.杀虫剂悖(bei)论	（测试用例应当定期修订和评审，增加新的或不同的测试用例）</span><br><span class="line">6.测试活动依赖于测试内容	（软件测试的活动开展依赖于所测试的内容）</span><br><span class="line">7.没有错误是好是谬论		（有可能99%没有bug的软件也是不能使用的）</span><br><span class="line">8.程序员不能自测之后上线</span><br><span class="line">9.严格执行测试计划，排除测试的随意性</span><br><span class="line">10.应当对每一个测试结果做全面的检查</span><br><span class="line">11.妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便 </span><br><span class="line">12.设计测试用例时，应当包括合理的输入数据和不合理的输入数据 </span><br><span class="line">13.测试用例应由测试数据和与之对应的预期输出结果这两部分组成</span><br></pre></td></tr></table></figure>



<h3 id="11-测试区分"><a href="#11-测试区分" class="headerlink" title="11.测试区分"></a>11.测试区分</h3><h4 id="11-1-按照测试原理分类："><a href="#11-1-按照测试原理分类：" class="headerlink" title="11-1.按照测试原理分类："></a>11-1.按照测试原理分类：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">黑盒测试：只关心输入数据和输出结果</span><br><span class="line">白盒测试：是一种按照程序内部逻辑结构和编码结构设计测试数据</span><br><span class="line">灰盒测试：一种程序运行时的外部变现同时又结合内部结构来设计测试数据的测试方法</span><br></pre></td></tr></table></figure>

<p><img src="/case/img10.jpg"></p>
<h4 id="11-2-按照测试阶段分类"><a href="#11-2-按照测试阶段分类" class="headerlink" title="11-2.按照测试阶段分类"></a>11-2.按照测试阶段分类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单元测试：对一个模块、一个函数或者一个类来测试</span><br><span class="line">集成测试：单元测试后，将单独的模块按照设计要求组装成子系统或系统，作为整体进行测试</span><br><span class="line">系统测试：集成测试后，将硬件、软件看作一个整体、对系统的功能及性能的总体测试</span><br><span class="line">验收测试：系统测试后，以用户测试为主，或有测试人员共同参与检验软件质量</span><br></pre></td></tr></table></figure>

<p><img src="/case/img11.jpg"></p>
<h4 id="11-3-按照内容分类"><a href="#11-3-按照内容分类" class="headerlink" title="11-3.按照内容分类"></a>11-3.按照内容分类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">功能测试、性能测试、兼容性测试</span><br></pre></td></tr></table></figure>

<h5 id="11-3-1-功能测试"><a href="#11-3-1-功能测试" class="headerlink" title="11-3.1.功能测试"></a>11-3.1.功能测试</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">功能测试：</span><br><span class="line">	根据产品操作描述和需求文档，测试一个产品的特性和可操作行为是否满足用户需求的</span><br><span class="line"></span><br><span class="line">界面测试：用户界面的模块的布局是否符合客户使用习惯，界面操作便捷性、导航简单易懂性性的测试</span><br><span class="line">冒烟测试：验证系统的核心功能是否能够正常运行的测试方法</span><br><span class="line">回归测试：修改了旧代码后，重新进行测试</span><br><span class="line">业务逻辑测试：在基本的功能点都已合格的基础上，准备多种测试数据</span><br><span class="line">易用性测试：指用户使用软件时是否感觉方便的测试</span><br></pre></td></tr></table></figure>



<h5 id="11-3-2-性能测试"><a href="#11-3-2-性能测试" class="headerlink" title="11-3.2.性能测试"></a>11-3.2.性能测试</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">性能测试：</span><br><span class="line">	通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行效验的测试方法。</span><br><span class="line">	</span><br><span class="line">压力测试：通过逐步增加系统负载，测试系统性能的变化，并确定在什么条件下系统性能处于失效状态。</span><br><span class="line">负载测试：通过逐步增加系统负载，测试系统性能的变化，在满足性能指标的情况下，系统所能承受的最大负载量的测试。</span><br><span class="line">并发测试：是一个负载测试和压力测试的过程，即逐渐增加并发用户数负载直到系统的瓶颈，通过分析资源监控指标来确定系统并发性能</span><br></pre></td></tr></table></figure>



<h5 id="11-3-3-兼容性测试"><a href="#11-3-3-兼容性测试" class="headerlink" title="11-3.3.兼容性测试"></a>11-3.3.兼容性测试</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">冒烟测试、随机测试、安全性测试、探索性测试、回归测试、Alpha测试、Beta测试</span><br><span class="line"></span><br><span class="line">随机测试：主要是根据测试者的经验无需测试用例对软件进行功能和性能抽查的测试方法</span><br><span class="line">安全性测试：通过不同的测试方法、检验程序、网络、数据库安全性的测试方法</span><br><span class="line">探索性测试：碰到问题时能随机应变，强调测试人员的主观能动性明确整体的测试计划的测试方法</span><br><span class="line">Alpha测试：内侧。α测试。内部环境下的测试，开发人员或测试人员在现场</span><br><span class="line">Beta测试：外侧、公测、β测试。生产环境下的测试，开发人员和测试人员都不在现场</span><br></pre></td></tr></table></figure>



<h3 id="12-测试计划"><a href="#12-测试计划" class="headerlink" title="12.测试计划"></a>12.测试计划</h3><h4 id="12-1-概念定义"><a href="#12-1-概念定义" class="headerlink" title="12-1.概念定义:"></a>12-1.概念定义:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">制定测试目的、范围、方法、时间进度及软件测试重点的过程</span><br></pre></td></tr></table></figure>

<h4 id="12-2-测试目的编写结构"><a href="#12-2-测试目的编写结构" class="headerlink" title="12-2.测试目的编写结构"></a>12-2.测试目的编写结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.目的的总体概述</span><br><span class="line">2.包含详细描述</span><br></pre></td></tr></table></figure>

<h4 id="12-3-测试目的编写内容"><a href="#12-3-测试目的编写内容" class="headerlink" title="12-3.测试目的编写内容"></a>12-3.测试目的编写内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.程序是否满足需求</span><br><span class="line">2.程序是否存在Bug</span><br><span class="line">3.系统或产品顺利发布</span><br></pre></td></tr></table></figure>

<h4 id="12-4-人力资源"><a href="#12-4-人力资源" class="headerlink" title="12-4.人力资源"></a>12-4.人力资源</h4><p><img src="/case/img011.jpg"></p>
<h4 id="12-5-系统资源"><a href="#12-5-系统资源" class="headerlink" title="12-5.系统资源"></a>12-5.系统资源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">硬件资源、软件资源</span><br></pre></td></tr></table></figure>

<h4 id="12-6-测试范围"><a href="#12-6-测试范围" class="headerlink" title="12-6.测试范围"></a>12-6.测试范围</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试对象、测试的特性、不测试的特性</span><br></pre></td></tr></table></figure>

<h4 id="12-7-测试风险"><a href="#12-7-测试风险" class="headerlink" title="12-7.测试风险"></a>12-7.测试风险</h4><p><img src="/case/img03.jpg"></p>
<h4 id="12-8-人员分工"><a href="#12-8-人员分工" class="headerlink" title="12-8.人员分工"></a>12-8.人员分工</h4><p><img src="/case/img04.jpg"></p>
<h4 id="12-9-测试策略"><a href="#12-9-测试策略" class="headerlink" title="12-9.测试策略"></a>12-9.测试策略</h4><p><img src="/case/img05.jpg"></p>
<h4 id="12-10-测试准则"><a href="#12-10-测试准则" class="headerlink" title="12-10.测试准则"></a>12-10.测试准则</h4><ul>
<li><p>启动准则：满足什么情况可以进行测试</p>
</li>
<li><p>暂停准则：遇到什么情况测试要暂停</p>
</li>
<li><p>再启动准则：在什么情况下可以重新启动测试</p>
</li>
<li><p>结束准则：什么情况可以停止测试</p>
<p><img src="/case/img066.jpg"></p>
</li>
</ul>
<p><img src="/case/img077.jpg"></p>
<h4 id="12-11-测试进度"><a href="#12-11-测试进度" class="headerlink" title="12-11.测试进度"></a>12-11.测试进度</h4><p><img src="/case/img10.jpg"></p>
<p><img src="/case/img088.jpg"></p>
<h4 id="12-12-测试输出"><a href="#12-12-测试输出" class="headerlink" title="12-12.测试输出"></a>12-12.测试输出</h4><p><img src="/case/img09.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>自学测试day06_07</title>
    <url>/2021/09/24/day06/</url>
    <content><![CDATA[<h1 id="day06"><a href="#day06" class="headerlink" title="day06"></a>day06</h1><h2 id="1-因果图"><a href="#1-因果图" class="headerlink" title="1.因果图"></a>1.因果图</h2><h3 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比较适合输入条件比较多的情况，测试所有的输入条件的排列组合。</span><br><span class="line">所谓的原因就是输入，所谓的结果就是输出</span><br></pre></td></tr></table></figure>

<h3 id="1-2因果图测试用例的编写过程"><a href="#1-2因果图测试用例的编写过程" class="headerlink" title="1.2因果图测试用例的编写过程"></a>1.2因果图测试用例的编写过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.确定原因、结果、中间过程</span><br><span class="line">2.连接因果图</span><br><span class="line">3.标明约束条件</span><br><span class="line">4.输出测试用例</span><br></pre></td></tr></table></figure>

<h3 id="1-3案例"><a href="#1-3案例" class="headerlink" title="1.3案例"></a>1.3案例</h3><table>
<thead>
<tr>
<th>编号</th>
<th>输入数据</th>
<th>预期结果</th>
<th>实际结果</th>
<th>是否通过</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>投入2.5元硬币，按“可乐”按钮</td>
<td>送出“可乐”饮料</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>投入2.5元硬币，按“啤酒”按钮</td>
<td>送出“啤酒”饮料</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>投入2.5元硬币，按“奶茶”按钮</td>
<td>送出“奶茶”饮料</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>投入3元硬币，按“可乐”按钮</td>
<td>退还5角硬币，送出“可乐”饮料</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>投入3元硬币，按“啤酒”按钮</td>
<td>退还5角硬币，送出“啤酒”饮料</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>投入3元硬币，按“奶茶”按钮</td>
<td>退还5角硬币，送出“奶茶”饮料</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-错误推测法"><a href="#2-错误推测法" class="headerlink" title="2.错误推测法"></a>2.错误推测法</h2><h3 id="2-1定义"><a href="#2-1定义" class="headerlink" title="2.1定义"></a>2.1定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基于经验和直觉推测程序中可能发送的各种错误，有针对性地设计。只能作为一种补充</span><br></pre></td></tr></table></figure>

<h3 id="2-2案例"><a href="#2-2案例" class="headerlink" title="2.2案例"></a>2.2案例</h3><p>测试手机终端的通话功能，可以设计各种通话失败的情况来补充测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.无SIM卡插入时进行呼出（非紧急呼叫）</span><br><span class="line">2.插入已欠费SIM卡进行呼出</span><br><span class="line">3.射频器件损坏或无信号区域插入有效的SIM卡呼出</span><br><span class="line">4.网络正常，插入有效的SIM卡，呼出无效号码(如1,333，不输入任何号码等)</span><br><span class="line">5.网络正常，插入有效的SIM卡，使用&quot;快速拨号&quot;功能呼出设置无效号码的数字</span><br></pre></td></tr></table></figure>

<h3 id="2-3技巧"><a href="#2-3技巧" class="headerlink" title="2.3技巧"></a>2.3技巧</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思考和分析测试对象的各个方面，多参考以前发现的bug的相关数据，总结的经验</span><br><span class="line">以一个攻击者的态度对待程序，就能设计出比较完善的测试用例来</span><br></pre></td></tr></table></figure>



<h2 id="3-判定表"><a href="#3-判定表" class="headerlink" title="3.判定表"></a>3.判定表</h2><h3 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设计测试用例时，分析和表达多输入条件下执行不同操作的黑盒测试方法</span><br></pre></td></tr></table></figure>

<p>注意：该方法和因果图法相似</p>
<h3 id="3-2编写过程"><a href="#3-2编写过程" class="headerlink" title="3.2编写过程"></a>3.2编写过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.确定原因和动作</span><br><span class="line">2.排列组合</span><br><span class="line">3.标明结果关系</span><br><span class="line">4.输出测试用例</span><br></pre></td></tr></table></figure>

<h3 id="3-3案例"><a href="#3-3案例" class="headerlink" title="3.3案例"></a>3.3案例</h3><p><strong>要求：</strong></p>
<p>对于发动机功率大于100马力的汽车<strong>并且</strong>维修记录不全<strong>或</strong>里程超过20万公里的汽车，应给予合作4s店优先的维修处理</p>
<p><strong>分析：</strong></p>
<p><img src="/case/day06_img01.jpg"></p>
<h2 id="4-正交实验法"><a href="#4-正交实验法" class="headerlink" title="4.正交实验法"></a>4.正交实验法</h2><h3 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工具：正交表</span><br><span class="line">包括两部分：是怎么安排实验、是怎么分析实验结果</span><br></pre></td></tr></table></figure>

<h3 id="4-2应用场景"><a href="#4-2应用场景" class="headerlink" title="4.2应用场景"></a>4.2应用场景</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个界面中有多个控件，每个控件有多个取值，控件之间可以互相组合，不可能为每一个组合编写一条用例，如何使用最少最优的组合进行测试。	--正交排列法</span><br></pre></td></tr></table></figure>





<h1 id="day07"><a href="#day07" class="headerlink" title="day07"></a>day07</h1><h2 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h2><h3 id="1-1定义-1"><a href="#1-1定义-1" class="headerlink" title="1.1定义"></a>1.1定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过模拟业务场景来对系统的功能点或业务流程的描述，从而提高测试效果的黑盒测试方法</span><br></pre></td></tr></table></figure>

<h3 id="1-2ATM引入场景法"><a href="#1-2ATM引入场景法" class="headerlink" title="1.2ATM引入场景法"></a>1.2ATM引入场景法</h3><p><img src="/case/day07_img01.jpg"></p>
<h3 id="1-3原理图"><a href="#1-3原理图" class="headerlink" title="1.3原理图"></a>1.3原理图</h3><p><img src="/case/day07_img02.jpg"></p>
<h3 id="1-4两个流"><a href="#1-4两个流" class="headerlink" title="1.4两个流"></a>1.4两个流</h3><h4 id="1-4-1基本流"><a href="#1-4-1基本流" class="headerlink" title="1.4.1基本流"></a>1.4.1基本流</h4><p>概念：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正确完成的流程</span><br></pre></td></tr></table></figure>

<p>流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插卡 → 输入密码 → 选择服务 → 取款 → 选择金额 → 等待出钞 → 取出卡片</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2备选流"><a href="#1-4-2备选流" class="headerlink" title="1.4.2备选流"></a>1.4.2备选流</h4><p>概念：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存在异常的流程，对于基本流的每一步都取反</span><br></pre></td></tr></table></figure>

<p>流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插卡 → 输入密码 → 密码错误 → 重新输入 → 密码正确 → 选择服务 → 取款 → 选择金额 → 等待出钞 → 取出卡片</span><br></pre></td></tr></table></figure>



<h3 id="1-5场景编写测试用例编写过程"><a href="#1-5场景编写测试用例编写过程" class="headerlink" title="1.5场景编写测试用例编写过程"></a>1.5场景编写测试用例编写过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.分析用户场景</span><br><span class="line">2.设计场景覆盖基本流和备选流</span><br><span class="line">3.输出测试用例</span><br></pre></td></tr></table></figure>

<h3 id="1-6-案例"><a href="#1-6-案例" class="headerlink" title="1.6 案例"></a>1.6 案例</h3><p><img src="/case/day07_img03.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 需求说明：</span><br><span class="line">	注册网站一共需要三个步骤，输入手机号，密码，输入正确的手机验证码、并同意服务协议后，点</span><br><span class="line">击立即申请，注册成功。信息填写错误时给出友好的提示信息，说明错误原因。注册成功后给注册</span><br><span class="line">用户发一条信息，信息内容如下：“您好！Xxx用户，欢迎您注册，请及时完成实名认证。” </span><br><span class="line">2. 测试点分析方法：</span><br><span class="line">2.1熟读需求：熟读3-5遍，读需求</span><br><span class="line">2.2断句：将需求整理成一段段要求</span><br><span class="line">2.3分类：流程&#x2F;规则</span><br><span class="line">2.4逆向思维：从不同地的方面进行考虑</span><br><span class="line">2.5质疑：将自己有疑问地方找出来</span><br><span class="line">2.6应用测试用例分析方法</span><br></pre></td></tr></table></figure>

<p><img src="/case/day07_img04.jpg"></p>
<p>使用相应的测试用例方法对测试点进行用例的编写，一个测试点对应一个或多个测试用例，而测试</p>
<p>用例只能对应某个测试点。</p>
]]></content>
  </entry>
  <entry>
    <title>自学测试day08</title>
    <url>/2021/09/26/day08/</url>
    <content><![CDATA[<h1 id="day08"><a href="#day08" class="headerlink" title="day08"></a>day08</h1><h2 id="1-缺陷报告"><a href="#1-缺陷报告" class="headerlink" title="1.缺陷报告"></a>1.缺陷报告</h2><h3 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标识并描述发现的缺陷，具有清晰，完整和可重视问题所需的信息的文档。</span><br><span class="line">测试人员发现缺陷，将缺陷记录在《缺陷报告》中，通过缺陷报告将缺陷告知给开发人员，并对缺陷进行跟踪和管理。缺陷报告是测试人员与开发人员之间重要的沟通方式。</span><br></pre></td></tr></table></figure>

<h3 id="1-2什么是缺陷"><a href="#1-2什么是缺陷" class="headerlink" title="1.2什么是缺陷"></a>1.2什么是缺陷</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bug，指在软件中（包括文档和程序）存在的影响软件正常运行的问题。</span><br><span class="line"></span><br><span class="line">1.软件未达到产品说明书标明的功能，如一个即时通讯APP不能聊天</span><br><span class="line">2.软件出现了产品说明书指明不会出现的错误，如高考不带身份证。</span><br><span class="line">3.软件功能超出产品说明书指明的范围，如即时通讯APP做了一个地图功能。</span><br><span class="line">4.软件未达到产品说明书虽未指出但应该达到的目标，如一个账号的密码是明文。</span><br><span class="line">5.软件难以理解、不易使用、运行速度缓慢或者从测试人员的角度看最终用户认为不好，如一个即时通讯APP无法找不到聊天界面。</span><br></pre></td></tr></table></figure>

<h3 id="1-3软件缺陷产生的原因"><a href="#1-3软件缺陷产生的原因" class="headerlink" title="1.3软件缺陷产生的原因"></a>1.3软件缺陷产生的原因</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.需求不明确和变更</span><br><span class="line">2.软件结构复杂</span><br><span class="line">3.编码问题</span><br><span class="line">4.项目期限短</span><br><span class="line">5.使用新技术</span><br></pre></td></tr></table></figure>

<h3 id="1-4导致软件缺陷的典型错误"><a href="#1-4导致软件缺陷的典型错误" class="headerlink" title="1.4导致软件缺陷的典型错误"></a>1.4导致软件缺陷的典型错误</h3><p><img src="/case/day08_img01.jpg"></p>
<h3 id="1-5软件缺陷分类"><a href="#1-5软件缺陷分类" class="headerlink" title="1.5软件缺陷分类"></a>1.5软件缺陷分类</h3><p><img src="/case/day08_img02.jpg"></p>
<h3 id="1-6缺陷报告的核心要素"><a href="#1-6缺陷报告的核心要素" class="headerlink" title="1.6缺陷报告的核心要素"></a>1.6缺陷报告的核心要素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.缺陷编号：缺陷的唯一标识符</span><br><span class="line">2.缺陷状态：缺陷跟踪过程的进展情况</span><br><span class="line">3.缺陷标题：缺陷的概述，描述问题本质</span><br><span class="line">4.重现步骤：</span><br><span class="line">		(1).一步一步描述再现缺陷的操作步骤</span><br><span class="line">		(2).预期结果</span><br><span class="line">		(3).实际结果</span><br><span class="line">5.严重程度：缺陷对软件系统的影响程度 </span><br><span class="line">6.优先级：修复缺陷的重要性或紧迫性</span><br><span class="line">7.缺陷类型：根据缺陷产生的来源和根源划分出的缺陷种类， </span><br><span class="line">		功能、配置、安装、性能缺陷</span><br><span class="line">8.测试环境：测试环境配置，包括软件环境和硬件环境</span><br></pre></td></tr></table></figure>

<p><img src="/case/day08_img03.jpg"></p>
<p><img src="/case/day08_img04.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新 建：刚发现的缺陷</span><br><span class="line">已指派：已经由测试人员将缺陷指派给开发人员进行处理</span><br><span class="line">已打开：开发人员正在修复缺陷</span><br><span class="line">已修复：开发人员完成缺陷修复，还未进行回归测试</span><br><span class="line">已拒绝：开发人员拒绝修复</span><br><span class="line">已延期：对缺陷进行延缓处理</span><br><span class="line">已关闭：由测试人员回归测试后，缺陷不存在了</span><br><span class="line">重新打开：由测试人员回归测试后，发现缺陷仍然存在。</span><br></pre></td></tr></table></figure>



<h3 id="1-7缺陷报告编写技巧"><a href="#1-7缺陷报告编写技巧" class="headerlink" title="1.7缺陷报告编写技巧"></a>1.7缺陷报告编写技巧</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.对错误的描述要做到简洁、准确、完整、揭示错误实质</span><br><span class="line">2.尽量使用短语和短句、避免复杂句型句式</span><br><span class="line">3.每个软件问题报告只书写一个缺陷或错误</span><br><span class="line">4.明确指明错误类型和严重程度</span><br><span class="line">5.每一个步骤尽量只记录一个完成操作</span><br><span class="line">6.复现的操作步骤要完整、准确、简短</span><br><span class="line">7.可以附加必要的错误特征图像</span><br><span class="line">8.可以附加必要的测试用例</span><br></pre></td></tr></table></figure>



<h3 id="1-8缺陷报告模块"><a href="#1-8缺陷报告模块" class="headerlink" title="1.8缺陷报告模块"></a>1.8缺陷报告模块</h3><p><img src="/case/day08_img05.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>自学测试day09</title>
    <url>/2021/09/27/day09/</url>
    <content><![CDATA[<h1 id="day09"><a href="#day09" class="headerlink" title="day09"></a>day09</h1><h2 id="1-测试报告"><a href="#1-测试报告" class="headerlink" title="1.测试报告"></a>1.测试报告</h2><h3 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记录测试的过程和结果，对发现的问题和缺陷进行分析的文档</span><br></pre></td></tr></table></figure>



<h3 id="1-2测试报告分类"><a href="#1-2测试报告分类" class="headerlink" title="1.2测试报告分类"></a>1.2测试报告分类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阶段测试报告、整体测试报告</span><br></pre></td></tr></table></figure>



<h3 id="1-3报告内容"><a href="#1-3报告内容" class="headerlink" title="1.3报告内容"></a>1.3报告内容</h3><h4 id="1-3-1概要"><a href="#1-3-1概要" class="headerlink" title="1.3.1概要"></a>1.3.1概要</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.编写目的：</span><br><span class="line">	（1）对测试报告进行响应的解释</span><br><span class="line">	（2）对项目进行简介</span><br><span class="line">	（3）对于测试任务进行简单描述，要测试哪些内容</span><br><span class="line">2.测试人员</span><br><span class="line">类似于测试计划中的人员分工，简单描述日期等</span><br><span class="line">3.测试环境</span><br><span class="line">软件和硬件环境</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2测试过程"><a href="#1-3-2测试过程" class="headerlink" title="1.3.2测试过程"></a>1.3.2测试过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阶段测试报告：</span><br><span class="line">		1.测试进度情况</span><br><span class="line">		2.用例执行情况</span><br><span class="line">		3.缺陷统计</span><br><span class="line">总体测试报告：</span><br><span class="line">		1.各版本的测试情况</span><br><span class="line">		2.各版本的缺陷统计</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3缺陷分析"><a href="#1-3-3缺陷分析" class="headerlink" title="1.3.3缺陷分析"></a>1.3.3缺陷分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.按照缺陷级别</span><br><span class="line">2.按照功能模块</span><br><span class="line">3.按照轮次</span><br><span class="line">4.缺陷总数</span><br><span class="line">5.缺陷类型</span><br><span class="line">6.缺陷趋势</span><br></pre></td></tr></table></figure>

<h4 id="1-3-4测试总结"><a href="#1-3-4测试总结" class="headerlink" title="1.3.4测试总结"></a>1.3.4测试总结</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.测试结论</span><br><span class="line">	通过&#x2F;不通过。</span><br><span class="line">	需求覆盖率100%，测试用例执行过率100%。</span><br><span class="line">	缺陷：致命&#x3D;0，严重&#x3D;0，一般&#x3D;0，提示&lt;&#x3D;10%。</span><br><span class="line">2.风险分析</span><br><span class="line">	测试进度、人员安排导致的风险。</span><br><span class="line">	测试内容考虑范围之外导致的风险。</span><br><span class="line">	测试环境不全面导致的风险。</span><br><span class="line">3.遗留问题</span><br><span class="line">	遗留问题描述、等级、处理方法。</span><br></pre></td></tr></table></figure>



<h2 id="2-测试报告模板"><a href="#2-测试报告模板" class="headerlink" title="2.测试报告模板"></a>2.测试报告模板</h2><h3 id="2-1编写目的"><a href="#2-1编写目的" class="headerlink" title="2.1编写目的"></a>2.1编写目的</h3><p>背景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本报告为XX1.0版本的测试报告，用于记录测试过程，总体测试情况，分析测试数据，归纳测试工作过程中的问题与遗留的风险，给出响应的测试建议供后序参考</span><br><span class="line">XX是Android平台的电商应用，1.0版本是首次发布版本。包含登录&#x2F;注册、商品展示&#x2F;搜索、购物车等功能</span><br></pre></td></tr></table></figure>

<p>测试内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对XX1.0版本进行了功能、性能、易用性、兼容性测试。功能测试覆盖以上所有功能；</span><br><span class="line">对登录和订单管理功能进行了性能测试；</span><br><span class="line">兼容性测试覆盖了Android6,7,8,9版本、华为、小米等主流厂家机型</span><br></pre></td></tr></table></figure>

<h3 id="2-2测试人员"><a href="#2-2测试人员" class="headerlink" title="2.2测试人员"></a>2.2测试人员</h3><p>测试工作6月1日开始，6月15日测试完成，测试组3人，总工作量45天。人员分工如下表：</p>
<table>
<thead>
<tr>
<th align="center">姓名</th>
<th>角色</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td align="center">测试经理</td>
<td>测试负责人</td>
<td>制定测试策略，编写测试计划，设计测试用例，编写测试报告</td>
</tr>
<tr>
<td align="center">工程师A</td>
<td>测试工程师</td>
<td>制定性能测试方案，进行性能测试，编写性能测试报告</td>
</tr>
<tr>
<td align="center">工程师B</td>
<td>测试工程师</td>
<td>设计测试用例，测试执行</td>
</tr>
</tbody></table>
<h3 id="2-3测试环境"><a href="#2-3测试环境" class="headerlink" title="2.3测试环境"></a>2.3测试环境</h3><table>
<thead>
<tr>
<th>配置</th>
<th>应用服务器</th>
<th>数据库服务器</th>
<th>测试机</th>
</tr>
</thead>
<tbody><tr>
<td>硬件配置</td>
<td>CPU：双核1.8G主频 Intel(R) Xeon(R) CPU 2GHz                                 内存：4G</td>
<td>CPU：双核1.8G主频 blntel(R) Xeon(R) CPU 2GHz                               内存：4G</td>
<td>CPU：1CPU（双核）， Intel(R) Pentium(R) CPU E2180 2.0GHz                        内存：8G</td>
</tr>
<tr>
<td>软件配置</td>
<td>Windows2008 server Tomcat 6.0（功能测试） Websphere 7.0(功能、性能测试)</td>
<td>CentOS7、Oracle 11g R2</td>
<td>Windows7+IE11，性能测试工具：Loadrunner11</td>
</tr>
</tbody></table>
<h2 id="3-测试过程"><a href="#3-测试过程" class="headerlink" title="3.测试过程"></a>3.测试过程</h2><h3 id="3-1测试进度"><a href="#3-1测试进度" class="headerlink" title="3.1测试进度"></a>3.1测试进度</h3><table>
<thead>
<tr>
<th>测试任务</th>
<th>责任人</th>
<th>启动时间</th>
<th>计划完成时间</th>
<th>完成时间</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>测试计划/评审</td>
<td>测试经理</td>
<td>2021.5.27</td>
<td>2021.5.27</td>
<td>2021.5.27</td>
<td></td>
</tr>
<tr>
<td>需求分析</td>
<td>测试工程师</td>
<td>2021.5.28</td>
<td>2021.5.28</td>
<td>2021.5.28</td>
<td></td>
</tr>
<tr>
<td>测试用例设计/评审</td>
<td>测试工程师</td>
<td>2021.5.29</td>
<td>2021.6.4</td>
<td>2021.6.6</td>
<td>需求变动，用例设计延迟2天完成。</td>
</tr>
</tbody></table>
<h3 id="3-2用例执行情况"><a href="#3-2用例执行情况" class="headerlink" title="3.2用例执行情况"></a>3.2用例执行情况</h3><table>
<thead>
<tr>
<th>模块</th>
<th>用例总数</th>
<th>执行用例数</th>
<th>通过用例数</th>
<th>未通过用例数</th>
<th>阻塞用例数</th>
</tr>
</thead>
<tbody><tr>
<td>登录/注册</td>
<td>50</td>
<td>50</td>
<td>48</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>购物车</td>
<td>75</td>
<td>73</td>
<td>70</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>支付</td>
<td>75</td>
<td>70</td>
<td>70</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>合计</td>
<td>200</td>
<td>193</td>
<td>188</td>
<td>5</td>
<td>7</td>
</tr>
</tbody></table>
<p>执行率 = 执行用例数 / 用例总数</p>
<p>通过率 = 通过用例数 / 执行总数</p>
<h3 id="3-3缺陷设计"><a href="#3-3缺陷设计" class="headerlink" title="3.3缺陷设计"></a>3.3缺陷设计</h3><p>1.0版本共发现缺陷21条，新增bug10个，修复17个，遗留bug4个。</p>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>bug总数</th>
<th>新增bug数</th>
<th>修复bug数</th>
<th>遗留bug数</th>
</tr>
</thead>
<tbody><tr>
<td>登录/注册</td>
<td>17</td>
<td>7</td>
<td>14</td>
<td>3</td>
</tr>
<tr>
<td>商品</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>合计</td>
<td>21</td>
<td>10</td>
<td>17</td>
<td>4</td>
</tr>
</tbody></table>
<p>修复率 = bug修复 / bug 总数</p>
<h2 id="4-缺陷分析"><a href="#4-缺陷分析" class="headerlink" title="4.缺陷分析"></a>4.缺陷分析</h2><h3 id="4-1缺陷级别分析"><a href="#4-1缺陷级别分析" class="headerlink" title="4.1缺陷级别分析"></a>4.1缺陷级别分析</h3><p><img src="/case/day09_img06.jpg"></p>
<p>解析：严重缺陷、一般缺陷、轻微缺陷各占各缺陷的5%，轻微缺陷占85%</p>
<h3 id="4-2缺陷模块分析"><a href="#4-2缺陷模块分析" class="headerlink" title="4.2缺陷模块分析"></a>4.2缺陷模块分析</h3><p><img src="/case/day09_img07.jpg"></p>
<p>解析：bug共21条，其中17条存在于登录/注册模块，开发人员需要着重对于该模块进行自测。</p>
<h3 id="4-3缺陷类型分析"><a href="#4-3缺陷类型分析" class="headerlink" title="4.3缺陷类型分析"></a>4.3缺陷类型分析</h3><p>按照版本统计</p>
<p>按照趋势统计</p>
<h2 id="5-测试总结"><a href="#5-测试总结" class="headerlink" title="5.测试总结"></a>5.测试总结</h2><h3 id="5-1测试理论"><a href="#5-1测试理论" class="headerlink" title="5.1测试理论"></a>5.1测试理论</h3><p>内容：通过/不通过，执行率、通过率、修复率、遗留问题的级别以及数量。</p>
<p>示例：XX1.1测试通过，可以上线。测试用例执行率100%，测试用例通过95%，未通过的测试用例不影响业务运行。严重缺陷为0，一般缺陷为0，轻微缺陷小于10%</p>
<h3 id="5-2风险分析"><a href="#5-2风险分析" class="headerlink" title="5.2风险分析"></a>5.2风险分析</h3><table>
<thead>
<tr>
<th>编号</th>
<th>风险描述</th>
<th>规避方法及建议</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="5-3遗留问题"><a href="#5-3遗留问题" class="headerlink" title="5.3遗留问题"></a>5.3遗留问题</h3><table>
<thead>
<tr>
<th>编号</th>
<th>缺陷描述</th>
<th>缺陷等级</th>
<th>处理方法</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>django+vue实现文件上传</title>
    <url>/2019/07/08/django-vue%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>利用Django实现文件上传上传，并不困难，下面开始介绍具体的几种方式</p>
<a id="more"></a>

<p>前端我们使用ant-design组件中的Upload控件实现</p>
<p>官方文档：<a href="https://www.antdv.com/components/upload-cn/">https://www.antdv.com/components/upload-cn/</a></p>
<p>下面是我们前端vue需要用到的具体代码，官方已经为我们写好了，我来解释一下具体参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;a-upload</span><br><span class="line">    name=<span class="string">&quot;file&quot;</span>			<span class="comment">// 传递到后端的key</span></span><br><span class="line">    :multiple=<span class="string">&quot;true&quot;</span>	<span class="comment">// 异步多个文件上传，true为开启</span></span><br><span class="line">    action=<span class="string">&quot;https://www.mocky.io/v2/5cc8019d300000980a055e76&quot;</span>	<span class="comment">// 代表请求的上传接口</span></span><br><span class="line">    :headers=<span class="string">&quot;headers&quot;</span>	<span class="comment">// 声明文件的头部，在data中定义</span></span><br><span class="line">    @change=<span class="string">&quot;handleChange&quot;</span>	<span class="comment">// 发送请求的方法</span></span><br><span class="line">  &gt;</span><br><span class="line">    &lt;a-button&gt; <span class="xml"><span class="tag">&lt;<span class="name">a-icon</span> <span class="attr">type</span>=<span class="string">&quot;upload&quot;</span> /&gt;</span></span> Click to Upload &lt;/a-button&gt;</span><br><span class="line">  &lt;/a-upload&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 文件头部信息</span></span><br><span class="line">      headers: &#123;</span><br><span class="line">        authorization: <span class="string">&#x27;authorization-text&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleChange</span>(<span class="params">info</span>)</span> &#123;		<span class="comment">// info：返回值</span></span><br><span class="line">      <span class="keyword">if</span> (info.file.status !== <span class="string">&#x27;uploading&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(info.file, info.fileList);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (info.file.status === <span class="string">&#x27;done&#x27;</span>) &#123;		<span class="comment">// 上传成功</span></span><br><span class="line">        <span class="built_in">this</span>.$message.success(<span class="string">`<span class="subst">$&#123;info.file.name&#125;</span> file uploaded successfully`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.file.status === <span class="string">&#x27;error&#x27;</span>) &#123;		<span class="comment">// 上传失败</span></span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">`<span class="subst">$&#123;info.file.name&#125;</span> file upload failed.`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-存储为静态文件"><a href="#1-存储为静态文件" class="headerlink" title="1. 存储为静态文件"></a>1. 存储为静态文件</h4><ul>
<li>前端发送过来的图片，django只需要把图片存放到配置好的静态目录下，并且将图片名存入到数据库中，通过静态路由+图片名就可以直接访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadFile</span>(<span class="params">View</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收参数</span></span><br><span class="line">        img = request.FILES.get(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立文件流</span></span><br><span class="line">        f = <span class="built_in">open</span>(os.path.join(UPLOAD_ROOT, <span class="string">&#x27;&#x27;</span>, img.name, ), <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        <span class="comment"># 写文件</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> img.chunks():</span><br><span class="line">            f.write(chunk)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭文件流</span></span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># with open(os.path.join(UPLOAD_ROOT, &#x27;&#x27;, img.name), &#x27;wb&#x27;) as f:</span></span><br><span class="line">        <span class="comment">#     # 写文件</span></span><br><span class="line">        <span class="comment">#     for chunk in img.chunks():</span></span><br><span class="line">        <span class="comment">#         f.write(chunk)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">&#x27;filename&#x27;</span>: img.name&#125;, ensure_ascii=<span class="literal">False</span>), content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意：在写文件时，可以有两种方式</p>
<ul>
<li>建立文件流，使用Python内置的<code>open()</code>函数，传入文件名和标示符，最后使用f.close()关闭文件流，否则会占用内存资源</li>
<li>with open语句，例如上文，每次建立文件流再关闭实在太繁琐，python引入了with语句来自动帮我们调用close()方法</li>
</ul>
<p>补充：img.chunks()：按块返回文件，通过在for循环中进行迭代，可以将大文件按块写入到<br>服务器中；</p>
<h4 id="2-存储base64编码"><a href="#2-存储base64编码" class="headerlink" title="2. 存储base64编码"></a>2. 存储base64编码</h4><p>首先来了解一下什么是base64，BASE64是一种编码方式，通常用于把二进制数据编码为可写的字符形式的数据。这是一种可逆的编码方式。Base64编码的作用：由于某些系统中只能使用ASCII字符，Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。是一种“防君子不防小人”的编码方式。</p>
<ul>
<li>优点：速度快，ascii字符，肉眼不可理解</li>
<li>编码比较长，非常容易被破解，仅适用于加密非关键信息的场合</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>).普通字符串编码</span><br><span class="line">s = <span class="string">&quot;我是一个字符串&quot;</span></span><br><span class="line"><span class="comment"># a bytes-like object is required</span></span><br><span class="line">encoder = base64.b64encode(s.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">print(encoder) <span class="comment"># byte类型 b&#x27;5oiR5piv5LiA5Liq5a2X56ym5Liy&#x27;</span></span><br><span class="line"></span><br><span class="line">str_encoder = encoder.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(str_encoder) <span class="comment"># str类型 5oiR5piv5LiA5Liq5a2X56ym5Liy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码过程</span></span><br><span class="line">decoder = base64.b64decode(str_encoder)</span><br><span class="line">print(decoder.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 我是一个字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>).图片编码</span><br><span class="line"><span class="comment"># 打开图片用二进制流方法</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;../static/upload/xxx.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 读取</span></span><br><span class="line">    data = f.read()</span><br><span class="line">    <span class="comment"># 进行编码</span></span><br><span class="line">    encodestr = base64.b64encode(data)	<span class="comment"># byte类型 b&#x27;5oiR5piv5LiA5Liq5a2X56ym5Liy&#x27;</span></span><br><span class="line">	<span class="comment"># 解码</span></span><br><span class="line">    print(<span class="built_in">str</span>(encodestr), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>要在数据库中存储base64时，需要将字段指定为longtext类型</p>
</li>
<li><p>base64编码的图片也可以直接在前端展示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;data:image/jpg(声明图片后缀);base64,编码&quot;</span> alt=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接方法：</span></span><br><span class="line"><span class="built_in">this</span>.img_url = <span class="string">&#x27;data:image/&#x27;</span> + <span class="built_in">this</span>.suffix + <span class="string">&#x27;;base64,&#x27;</span> + <span class="built_in">this</span>.b64</span><br><span class="line"></span><br><span class="line"><span class="comment">// avatar头像展示,动态绑定拼接好的base64</span></span><br><span class="line">&lt;a-avatar :src=<span class="string">&quot;img_url&quot;</span> style=<span class="string">&quot;margin-left: 10px;&quot;</span>&gt;&lt;/a-avatar&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-上传到云端"><a href="#3-上传到云端" class="headerlink" title="3. 上传到云端"></a>3. 上传到云端</h4><p>企业云盘，可以为企业提供一个集中存储、管理文件的平台，避免文件的分散、无序，避免电脑病毒、硬盘破损等带来的文件丢失，文件分享更便捷，增强办公的协同性。</p>
<p>常用云端：七牛云、阿里云、又拍云</p>
<p>以又拍云为例子：</p>
<p>首先安装又拍云sdk</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install unyun</span><br></pre></td></tr></table></figure>

<p>视图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义文件上传类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadFile</span>(<span class="params">View</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line"></span><br><span class="line">        img = request.FILES.get(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        up = upyun.UpYun(<span class="string">&#x27;你的空间名称&#x27;</span>, username=<span class="string">&#x27;操作员账号&#x27;</span>, password=<span class="string">&#x27;操作员密码&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        headers = &#123; <span class="string">&#x27;x-gmkerl-rotate&#x27;</span>: <span class="string">&#x27;auto&#x27;</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> img.chunks():</span><br><span class="line">            res = up.put(<span class="string">&#x27;/touxiang1.jpg&#x27;</span>, chunk, checksum=<span class="literal">True</span>, headers=headers)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#返回结果</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">&#x27;filename&#x27;</span>:img.name&#125;),content_type=<span class="string">&#x27;application/json&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上传成功的图片可以通过又拍云分配的空间域名+图片名来进行访问</p>
<p>又拍云上传参考大神技术博客：<a href="https://v3u.cn/a_id_140">https://v3u.cn/a_id_140</a></p>
]]></content>
  </entry>
  <entry>
    <title>django优缺点总结</title>
    <url>/2020/01/25/django%E4%BC%98%E7%BC%BA%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Django优缺点总结"><a href="#Django优缺点总结" class="headerlink" title="Django优缺点总结"></a>Django优缺点总结</h2><p>Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。</p>
<p>使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容。凡事都有两面性，django这么便捷的同时，它又有什么优势和缺陷呢？一起来看看</p>
<a id="more"></a>

<p>Django 本身基于 MVC 模型，即 Model+ View+ Controller设计模式</p>
<h3 id="MVC与MVT模型"><a href="#MVC与MVT模型" class="headerlink" title="MVC与MVT模型"></a>MVC与MVT模型</h3><p>MVC 模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制（Controller）。</p>
<ul>
<li>模型（Model）：编写程序应用的功能，负责业务对象与数据库的映射（ORM）。</li>
<li>视图（View）：图形界面，负责与用户的交互。</li>
<li>控制器（Controller）：负责转发请求，对请求进行处理。</li>
</ul>
<hr>
<p>MVT模型本质上和MVC是一样的，也是为了为了各组件间保持松耦合关系，只是定义上有些许不同。Django中的MVT分别是指：</p>
<ul>
<li>模型（Model）：负责业务对象与数据库的映射(ORM)。</li>
<li>视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。</li>
<li>模板（Template）：负责把html页面展示给用户</li>
</ul>
<p>回到正题：django是基于MVC模型的，这种设计模式的核心是：<strong>解耦，让不同的代码块之间降低耦合，增强代码的可扩展和可移植性，实现向后兼容。</strong></p>
<h3 id="django的优点"><a href="#django的优点" class="headerlink" title="django的优点"></a>django的优点</h3><ul>
<li>功能完善、要素齐全：自带大量常用工具和框架（比如分页，auth，权限管理), 适合快速开发企业级网站。</li>
<li>完善的文档：经过十多年的发展和完善，Django有广泛的实践案例和完善的在线文档。开发者遇到问题时可以搜索在线文档寻求解决方案。</li>
<li>强大的数据库访问组件：Django的Model层自带数据库ORM组件，使得开发者无须学习SQL语言即可对数据库进行操作。</li>
<li>自带台管理系统admin：只需要通过简单的几行配置和代码就可以实现一个完整的后台数据管理控制平台。</li>
</ul>
<h3 id="django的缺点"><a href="#django的缺点" class="headerlink" title="django的缺点"></a>django的缺点</h3><ul>
<li>大包大揽: 对于一些轻量级应用不需要的功能模块Django也包括了，不如Flask轻便。</li>
<li>过度封装: 很多类和方法都封装了，直接使用比较简单，但改动起来就比较困难。</li>
<li>性能劣势: 与C, C++性能上相比，Django性能偏低，当然这是python的锅，其它python框架在流量上来后会有同样问题。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>django实现聊天室并设置限流</title>
    <url>/2020/04/15/django%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p>前言：上次讲了<code>websoket</code>的基础知识和应用插件，今天我们来用<code>websocket</code>来实现一个聊天程序。</p>
<a id="more"></a>

<h4 id="实现功能简述"><a href="#实现功能简述" class="headerlink" title="实现功能简述"></a>实现功能简述</h4><p>要实现多人聊天室的核心就是区分当前用户发送的消息与其他用户发送的消息，在这里我通过用户登录使用的用户名来进行区分。</p>
<h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p>前端：vue-cli客户端</p>
<p>后端：django服务端</p>
<hr>
<p>首先，我们还是在前端vue定义一个组件，用来发送和展示消息</p>
<h4 id="1-连接websocket"><a href="#1-连接websocket" class="headerlink" title="1. 连接websocket"></a>1. 连接websocket</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断浏览器是否支持websocket</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params"><span class="string">&quot;WebSocket&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;支持&quot;</span>)</span><br><span class="line">            <span class="comment">// 生成websocket链接</span></span><br><span class="line">            <span class="keyword">var</span> uid = <span class="built_in">this</span>.token;</span><br><span class="line">            <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="built_in">this</span>.GLOBAL.ws_url);</span><br><span class="line">            <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送链接请求</span></span><br><span class="line">            ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                ws.send(uid)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">                <span class="comment">// 将获取信息打印</span></span><br><span class="line">                <span class="keyword">var</span> received_msg = evt.data;</span><br><span class="line">                <span class="comment">// 后端发送的消息放入聊天记录</span></span><br><span class="line">                <span class="comment">// _this.msg_list.push(received_msg)</span></span><br><span class="line">                _this.$notification.open(&#123;</span><br><span class="line">                    message: <span class="string">&#x27;消息提示框&#x27;</span>,</span><br><span class="line">                    description: received_msg</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 捕获断开链接</span></span><br><span class="line">            ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;链接已经关闭&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在vue的生命周期中连接服务端，并且保持长连接</p>
<h4 id="2-服务端核心代码"><a href="#2-服务端核心代码" class="headerlink" title="2. 服务端核心代码"></a>2. 服务端核心代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatroomMessage</span>(<span class="params">APIView</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="comment"># 获取参数</span></span><br><span class="line">        msg = request.data.get(<span class="string">&#x27;msg&#x27;</span>)</span><br><span class="line">        token = request.data.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">        uid = decode_jwt(token).get(<span class="string">&#x27;uid&#x27;</span>)</span><br><span class="line">        username = User.objects.get(pk=uid).username</span><br><span class="line"></span><br><span class="line">        msg = username + <span class="string">&quot;：&quot;</span> + msg</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> uid <span class="keyword">in</span> chatroom_clients:</span><br><span class="line">            <span class="comment"># 获取当前对象的消息数，没有消息时为None</span></span><br><span class="line">            count = r1.hget(username, <span class="string">&#x27;count&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                <span class="comment"># 拿到消息数，判断数量是否大于3次</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(count.decode()) &gt; <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;发送频繁&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">400</span>&#125;)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    chatroom_clients[uid].send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">                    <span class="comment"># 将哈希表中的count+1</span></span><br><span class="line">                    r1.hincrby(username, <span class="string">&#x27;count&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">                    r1.expire(username, <span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;OK&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 没有消息，直接发送并设置有效期</span></span><br><span class="line">                chatroom_clients[uid].send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">                r1.hincrby(username, <span class="string">&#x27;count&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">                r1.expire(username, <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;OK&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>不难看出，上面的代码只是接收了几个必要的参数，msg是用户输入的消息，并且获取当前用户的token头信息，解密出来用户id和用户名。接着就是利用redis缓存实现简单的限流功能，整体思路是：用户输入消息点击发送，为了防止用户恶意刷屏，我们需要判断他是否频繁发送，这里我们设置发送消息频率为10秒3条，可以利用redis哈希的特性，设定一个哈希表，每次消息发送成功都让count+1，并设置有效期为10秒，如果count&gt;3，则不发送消息。</p>
<h4 id="3-页面效果"><a href="#3-页面效果" class="headerlink" title="3. 页面效果"></a>3. 页面效果</h4><p>聊天室首页</p>
<p><img src="/.%5Cimages%5C%E8%81%8A%E5%A4%A9%E5%AE%A4.png"></p>
<p>点击咨询客服可以看到如下效果</p>
<p><img src="/.%5Cimages%5C%E5%92%A8%E8%AF%A2%E5%AE%A2%E6%9C%8D.png"></p>
<p>页面中我们看到两个额外的小功能，一个就是显示当前在线人数，另一个可以发送emoji表情</p>
<p>都是很简单就可以实现的，记录一下。</p>
<ul>
<li>统计在线人数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取客户端ip</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetOnlines</span>(<span class="params">APIView</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;HTTP_X_FORWORDED_FOR&quot;</span> <span class="keyword">in</span> request.META:</span><br><span class="line"></span><br><span class="line">            ip = request.META.get(<span class="string">&quot;HTTP_X_FORWORDED_FOR&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip = request.META.get(<span class="string">&quot;REMOTE_ADDR&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        print(ip)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> r.scard(<span class="string">&quot;set_ip&quot;</span>):</span><br><span class="line">            r.sadd(<span class="string">&quot;set_ip&quot;</span>, ip)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r.sadd(<span class="string">&quot;set_ip&quot;</span>, ip)</span><br><span class="line">            r.expire(<span class="string">&quot;set_ip&quot;</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;online&quot;</span>: r.scard(<span class="string">&quot;set_ip&quot;</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>实现原理就是获取当前请求的IP，将此ip存入一个不会重复的容器，并且获取它的个数，而刚好redis的集合就有这种特性，并且性能极高</p>
<ul>
<li>emoji表情</li>
</ul>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install emoji-vue --save</span><br></pre></td></tr></table></figure>

<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueEmoji <span class="keyword">from</span> <span class="string">&#x27;emoji-vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//在组件def</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">      <span class="function"><span class="title">onInput</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">          <span class="comment">//事件。数据包含文本区域的值</span></span><br><span class="line">          <span class="built_in">this</span>.message = event.data</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">clearTextarea</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$refs.emoji.clear()</span><br><span class="line">      &#125;,  </span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    VueEmoji</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在模板部分</span></span><br><span class="line">&lt;VueEmoji ref=<span class="string">&quot;emoji&quot;</span> @input=<span class="string">&quot;onInput&quot;</span> :value=<span class="string">&quot;message&quot;</span> /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里，一个简单的多人聊天室已经基本实现了，日常学习记录，一起进步！</p>
]]></content>
  </entry>
  <entry>
    <title>docker介绍以及安装使用</title>
    <url>/2018/06/01/docker%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-Docker核心概念"><a href="#1-Docker核心概念" class="headerlink" title="1. Docker核心概念"></a>1. Docker核心概念</h2><p> Docker 镜像（Image）就是一个只读的模板。例如：一个镜像可以包含一个完整的操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器，一个镜像可</p>
 <a id="more"></a>
<p> 以创建很多容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p>
<p>仓库(repository) 仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括 时速云 、网易云 等，可以提供大陆用户更稳定快速的访问。当然，用户也可以在本地网络内创建一个私有仓库。</p>
<p>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p>
<p>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p>
<p>容器(container) Docker 利用容器（Container）来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<hr>
<h2 id="2-Docker安装"><a href="#2-Docker安装" class="headerlink" title="2. Docker安装"></a>2. Docker安装</h2><h4 id="2-1-DockerToolbox"><a href="#2-1-DockerToolbox" class="headerlink" title="2.1 DockerToolbox"></a>2.1 DockerToolbox</h4><ol>
<li><p>下载安装包：<a href="http://get.daocloud.io/toolbox/">http://get.daocloud.io/toolbox/</a></p>
</li>
<li><p>安装过程中需要注意：</p>
<ul>
<li>确保cpu虚化在开启状态（默认开启）</li>
<li>如果已安装Git，可以不勾选Git for Windows，否则会覆盖掉</li>
<li>VirtualBox，虚拟机，需要勾选</li>
<li>Docker Compose for Windows，编排Docker容器的一种技术，能够同时操作多个Docker容器，建议勾选</li>
<li>完成安装后需要修改属性，把目标位置的Git路径修改为自己的Git路径</li>
</ul>
</li>
<li><p>安装完成，首次打开以后会自动下载光盘映像文件<strong>boot2docker.iso</strong>，但是下载是用的外源，为了节省时间，可以直接将iso文件拷贝到<code>C:\Users\ASUS\.docker\machine\cache</code></p>
</li>
</ol>
<h4 id="2-2-切换阿里镜像源"><a href="#2-2-切换阿里镜像源" class="headerlink" title="2.2 切换阿里镜像源"></a>2.2 切换阿里镜像源</h4><ol>
<li><p>注册阿里云账号</p>
</li>
<li><p>进入<a href="https://cr.console.aliyun.com/%EF%BC%8C%E7%82%B9%E5%87%BB%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8%EF%BC%8C%E5%A4%8D%E5%88%B6%E5%8A%A0%E9%80%9F%E5%99%A8%E5%9C%B0%E5%9D%80">https://cr.console.aliyun.com/，点击镜像加速器，复制加速器地址</a></p>
<img src="https://img2020.cnblogs.com/blog/2017056/202010/2017056-20201026211746502-716763173.png" style="zoom:50%;" />
</li>
<li><p>在docker命令行中输入</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker-machine ssh default</span><br><span class="line"><span class="comment"># 登录默认镜像</span></span><br><span class="line"></span><br><span class="line">sudo sed -i <span class="string">&quot;s|EXTRA_ARGS=&#x27;|EXTRA_ARGS=&#x27;--registry-mirror=https://3fqw5445.mirror.aliyuncs.com |g&quot;</span> /var/lib/boot2docker/profile</span><br><span class="line"><span class="comment"># 执行当前命令</span></span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"><span class="comment"># 退出镜像</span></span><br><span class="line"></span><br><span class="line">docker-machine restart default</span><br><span class="line"><span class="comment"># 重启镜像</span></span><br><span class="line"></span><br><span class="line">docker info</span><br><span class="line"><span class="comment"># 查看镜像信息</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="3-docker常用命令"><a href="#3-docker常用命令" class="headerlink" title="3. docker常用命令"></a>3. docker常用命令</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker info</span><br><span class="line"><span class="comment"># 查看docker环境信息，用于检测docker是否正确安装，结合docker version使用</span></span><br><span class="line"></span><br><span class="line">docker --versions</span><br><span class="line"><span class="comment"># 显示版本号</span></span><br><span class="line"></span><br><span class="line">docker load -i <span class="string">&#x27;E:/Month08/image/workflow.tar&#x27;</span>	<span class="comment"># 镜像的绝对路径</span></span><br><span class="line"><span class="comment"># 加载本地镜像</span></span><br><span class="line"></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 列出所有的镜像</span></span><br><span class="line"></span><br><span class="line">docker run -itd -p <span class="number">80</span>:<span class="number">80</span> &lt;镜像<span class="built_in">id</span>&gt;</span><br><span class="line"><span class="comment"># 运行服务(加d为守护进程运行)</span></span><br><span class="line"></span><br><span class="line">docker stop &lt;容器<span class="built_in">id</span>&gt;</span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 默认显示当前正在运行中的container</span></span><br><span class="line"></span><br><span class="line">docker ps -a </span><br><span class="line"><span class="comment"># 查看包括已经停止的所有容器</span></span><br><span class="line"></span><br><span class="line">docker rmi -f &lt;镜像<span class="built_in">id</span>&gt;</span><br><span class="line"><span class="comment"># 删除镜像(加-f强制删除)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
  </entry>
  <entry>
    <title>docker部署django项目</title>
    <url>/2020/08/22/docker%E9%83%A8%E7%BD%B2django%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="docker部署django项目"><a href="#docker部署django项目" class="headerlink" title="docker部署django项目"></a>docker部署django项目</h2><p>Django在生产环境的部署还是比较复杂的，令很多新手望而生畏, 幸运的是使用Docker容器化技术可</p>
<a id="more"></a>

<p>以大大简化我们Django在生产环境的部署。<em>Docker</em> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移动的镜像中，然后发布到任何流行的 Linux机器上。由于未来使用Docker部署Django是大势所趋，于是总结下Docker部署Django的整个过程。</p>
<h3 id="1-安装Docker和gunicorn"><a href="#1-安装Docker和gunicorn" class="headerlink" title="1.安装Docker和gunicorn"></a>1.安装Docker和gunicorn</h3><p>首先是安装docker，Docker官方文档推荐使用Docker Desktop。</p>
<p><img src="https://img-blog.csdnimg.cn/20201122231706863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>随后在宿主机安装gunicorn，容器内我们使用异步的方式来启动Django</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install gunicorn gevent</span><br></pre></td></tr></table></figure>

<h3 id="2-Django项目配置"><a href="#2-Django项目配置" class="headerlink" title="2.Django项目配置"></a>2.Django项目配置</h3><p>配置<code>settings.py</code>对应的应用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;corsheaders&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;myapp&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dwebsocket&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;gunicorn&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后在Django项目的根目录编写gunicorn的配置文件：<code>gunicorn.conf.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">bind = <span class="string">&#x27;0.0.0.0:8000&#x27;</span>   <span class="comment"># 绑定的ip与端口</span></span><br><span class="line">workers = <span class="number">1</span>             <span class="comment"># 进程数</span></span><br></pre></td></tr></table></figure>

<p>这里注意一点，ip必须是0.0.0.0，不要写成127.0.0.1,否则外部环境会访问不到容器内的服务，接下来在项目的根目录编写好依赖列表：requirements.txt</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要保证开发与生产环境的一致性</span></span><br><span class="line"><span class="comment"># 1. 在开发机的虚拟环境中运行以下命令：</span></span><br><span class="line">pip freeze &gt; requirements.txt         (&gt;：定向输出符)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 在新的环境中运行命令：</span></span><br><span class="line">pip install -r requirements.txt路径</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，某些依赖的库最好用==标注出小版本，因为一会在容器内通过pip安装的时候，系统有可能会自动帮你安装最新版导致一些依赖报错。</p>
<h3 id="3-Dockerfile文件"><a href="#3-Dockerfile文件" class="headerlink" title="3.Dockerfile文件"></a>3.Dockerfile文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立python3.7环境</span></span><br><span class="line">FROM python:<span class="number">3.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器内工作目录</span></span><br><span class="line">WORKDIR /Project/mydjango</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入依赖</span></span><br><span class="line">COPY requirements.txt ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置pip源为国内源</span></span><br><span class="line">RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将项目代码copy到容器内，第一个.代表宿主机，第二个.代表容器</span></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编码格式，防止中文乱码</span></span><br><span class="line">ENV LANG C.UTF<span class="number">-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;mydjango.wsgi:application&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;./gunicorn.conf.py&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>OK，万事俱备，进入到项目根目录下运行命令对项目进行打包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker build -t <span class="string">&#x27;mydjango&#x27;</span> .</span><br></pre></td></tr></table></figure>

<p>第一次打包编译的时候，可能时间会长一点，原因是因为requirements中的依赖包较多，可以删掉一些本项目用不到的包，前提是在你确定用不到的情况下。如果中途遇到网络错误导致的失败，反复执行打包命令即可。</p>
<p>在打包完成后，执行查看镜像命令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>可以看到编译好的镜像已经在docker容器中了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">E:\mydjango&gt;docker images</span><br><span class="line">REPOSITORY          TAG           IMAGE ID           CREATED            SIZE</span><br><span class="line">mydjango            latest        ecae54bab0da       <span class="number">24</span> hours ago       <span class="number">1.46</span>GB</span><br></pre></td></tr></table></figure>

<h3 id="启动镜像服务"><a href="#启动镜像服务" class="headerlink" title="启动镜像服务"></a>启动镜像服务</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run -it --rm -p <span class="number">8000</span>:<span class="number">8000</span> mydjango	<span class="comment"># 宿主机端口:容器映射</span></span><br></pre></td></tr></table></figure>

<p>使用端口映射技术将宿主机的8000端口映射到容器内的8000端口，访问Django服务，http://容器ip:8000</p>
<p><img src="https://img-blog.csdnimg.cn/20201122231735877.png#pic_center"></p>
<p>搞定！下篇介绍Docker部署前端vue项目</p>
]]></content>
  </entry>
  <entry>
    <title>docker部署vue项目</title>
    <url>/2020/08/24/docker%E9%83%A8%E7%BD%B2vue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>上篇介绍了为何使用docker容器式部署，以及部署django后端项目，接下来就轮到我们的前端服务vue.js了，其实是大同小异的，详情请继续看</p>
<a id="more"></a>

<p>首先打开vue项目的打包配置文件config/index.js</p>
<h3 id="1-vue打包配置文件"><a href="#1-vue打包配置文件" class="headerlink" title="1. vue打包配置文件"></a>1. vue打包配置文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">build: &#123;</span><br><span class="line">    <span class="comment">// Template for index.html</span></span><br><span class="line">    index: path.resolve(__dirname, <span class="string">&#x27;../dist/index.html&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Paths</span></span><br><span class="line">    assetsRoot: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">    assetsSubDirectory: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">    assetsPublicPath: <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Source Maps</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    productionSourceMap: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// https://webpack.js.org/configuration/devtool/#production</span></span><br><span class="line">    devtool: <span class="string">&#x27;#source-map&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gzip off by default as many popular static hosts such as</span></span><br><span class="line">    <span class="comment">// Surge or Netlify already gzip all static assets for you.</span></span><br><span class="line">    <span class="comment">// Before setting to `true`, make sure to:</span></span><br><span class="line">    <span class="comment">// npm install --save-dev compression-webpack-plugin</span></span><br><span class="line">    productionGzip: <span class="literal">false</span>,</span><br><span class="line">    productionGzipExtensions: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the build command with an extra argument to</span></span><br><span class="line">    <span class="comment">// View the bundle analyzer report after build finishes:</span></span><br><span class="line">    <span class="comment">// `npm run build --report`</span></span><br><span class="line">    <span class="comment">// Set to `true` or `false` to always turn it on or off</span></span><br><span class="line">    bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将项目目录改成相对路径，同时注意路由的配置，如果曾经修改为history模式记得改回hash：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes:routes,</span><br><span class="line">  mode:<span class="string">&#x27;hash&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-Dockerfile文件"><a href="#2-Dockerfile文件" class="headerlink" title="2.Dockerfile文件"></a>2.Dockerfile文件</h3><p>准备工作完毕，在vue的项目根目录下编写Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:lts-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># install simple http server for serving static content</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install -g http-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make the &#x27;app&#x27; folder the current working directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy both &#x27;package.json&#x27; and &#x27;package-lock.json&#x27; (if available)</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install project dependencies</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy project files and folders to the current working directory (i.e. &#x27;app&#x27; folder)</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build app for production with minification</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># port</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;http-server&quot;</span>, <span class="string">&quot;dist&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>这里我们选择体积更小的alpine镜像。</p>
<h3 id="3-打包镜像"><a href="#3-打包镜像" class="headerlink" title="3.打包镜像"></a>3.打包镜像</h3><p>随后进入项目的根目录，执行打包命令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker build -t myvue .</span><br></pre></td></tr></table></figure>

<p>myvue为你vue项目名称，同django项目一样，系统会自动根据脚本进行安装依赖，第一次也需要等待一段时间。</p>
<p>打包完成后，查看镜像：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>可以看到前端镜像的体积要小一点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\myvue&gt;docker images</span><br><span class="line">REPOSITORY          TAG             IMAGE ID         CREATED             SIZE</span><br><span class="line">myvue               latest          475b8cf5f19f     19 hours ago        572MB</span><br></pre></td></tr></table></figure>

<h3 id="4-启动镜像服务"><a href="#4-启动镜像服务" class="headerlink" title="4.启动镜像服务"></a>4.启动镜像服务</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -it --rm -p 8081:8080 myvue</span></span><br></pre></td></tr></table></figure>

<p>同样使用端口映射，这次宿主机使用8081，当然了，如果需要可以根据喜好进行修改。</p>
<p>访问vue.js服务</p>
<p><img src="https://img-blog.csdnimg.cn/20201122231851650.png#pic_center"></p>
<p>至此，通过Docker的容器技术，我们就将前后端两大服务都分别部署好了，花时间学习使用Docker部署项目是非常值得的。因为构建的镜像是可以复用的，一但你熟悉了项目的布局和使用Docker部署和启动服务的基本流程，你会发现部署变得非常简单了，而且再也不用担心宿主机所在的操作系统或环境，真正实现了项目的可移植</p>
<p>ps：</p>
<p>–rm：在Docker容器退出时，默认容器内部的文件系统仍然被保留，以方便调试并保留用户数据。</p>
<p>但是，对于foreground容器，由于其只是在开发调试过程中短期运行，其用户数据并无保留的必要，因而可以在容器启动时设置–rm选项，这样在容器退出时就能够自动清理容器内部的文件系统。</p>
<p>部署中遇到的坑：</p>
<ol>
<li><p>如果在执行第三步打包镜像出故障的话，可以先在执行npm run build进行生产环境打包部署</p>
</li>
<li><p>导致npm run build失败有可能是有的第三方插件出问题，例如在此项目中我引用了一个emoji插件，导致打包部署一直失败，将它弃用之后就成功了，所以有可能是第三方插件的原因导致的。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>git</title>
    <url>/2021/04/06/git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul>
<li>初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<ul>
<li>代码拉取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.git clone 地址     </span><br><span class="line">2.git pull 地址 </span><br></pre></td></tr></table></figure>

<ul>
<li>代码提交</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.git add -A</span><br><span class="line">2.git add .</span><br></pre></td></tr></table></figure>

<ul>
<li>提交说明/理由</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;first&#39;      注：&#39;first&#39;   可以修改自己的理由或说明</span><br></pre></td></tr></table></figure>

<ul>
<li>连接远程仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin 自己的仓库地址</span><br></pre></td></tr></table></figure>

<ul>
<li>上传到仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>



<ul>
<li>分支拉取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<ul>
<li>查看分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看全部分支</span><br><span class="line">git branch -a</span><br><span class="line">查看远端分支</span><br><span class="line">git branch -r</span><br><span class="line">查看当前分支</span><br><span class="line">git branch</span><br></pre></td></tr></table></figure>

<ul>
<li>转换分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure>

<ul>
<li>复制分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure>

<ul>
<li>合并分支不保留记录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rbase</span><br></pre></td></tr></table></figure>

<ul>
<li>查看所有提交的日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<ul>
<li>回退</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset -hard 日志id</span><br></pre></td></tr></table></figure>

<ul>
<li>强制头部推</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push orgin HEAD --force</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>jwt解密</title>
    <url>/2021/01/14/jwt%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<p>jwt：</p>
<pre><code>import jwt
import datetime

# 载荷信息
playload = &#123;&#39;exp&#39;: int((datetime.datetime.now() + datetime.timedelta(seconds=30)).timestamp()),
            &#39;data&#39;: &#123;&#39;uid&#39;: 8, &#39;username&#39;: &#39;test&#39;&#125;&#125;

# 编码
encode_jwt = jwt.encode(playload, &#39;test&#39;, algorithm=&#39;HS256&#39;)


# 强转
encode_str = str(encode_jwt, &#39;utf-8&#39;)

print(encode_str)

# 解密
decode_jwt = jwt.decode(&#39;encode_str&#39;, &#39;test&#39;, algorithms=[&#39;HS256&#39;])
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>kwarys,arys,with,evel,多线程，多进程</title>
    <url>/2021/03/10/kwarys,arys,with,evel,%E5%A4%9A%E7%BA%BF%E7%A8%8B,%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>kwarys用来传键值对</p>
<p>arys用来传有序的</p>
<p>with 关键字使用 : 省略开始，关闭</p>
<p>eval():<br>    eval函数就是实现list dict tuple与str之间的转化</p>
<p>多线程:<br>    适用于io密集型任务</p>
<p>多进程:<br>    适用于cup密集型任务</p>
<p>线程池：节约了开启，关闭的时间，提高了效率</p>
<p>多线程的弊端：发生资源分配竞争</p>
<p>自醒机制：dir()</p>
]]></content>
  </entry>
  <entry>
    <title>python内存管理</title>
    <url>/2018/11/30/python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>python内存管理</p>
<p><strong>对象存储</strong></p>
<p>首先，在python中，万物皆对象，每个对象第一次被创建时都会在内存中开辟</p>
<p>一块空间来存储。</p>
<a id="more"></a>

<p><strong>引用计数</strong></p>
<p>每创建一个对象，对应的引用为1。如果这个对象被赋值或引用时，对应的引用计数+1，如果被销毁，引用计数-1。若该对象的引用计数为0时，对象会自动销毁。</p>
<p><strong>循环引用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_list = []</span><br><span class="line">b_list = []</span><br><span class="line">a_list.append(b_list)</span><br><span class="line">b_list.append(a_list)</span><br></pre></td></tr></table></figure>

<p>a_list与b_list相互引用，如果不存在其他对象对他们的引用。a_list与b_list的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。</p>
<p><strong>标记-清除</strong></p>
<p>标记清除机制其实就是为了解决循环引用问题的，首先遍历所有对象，如果对象除了循环引用外还有别的引用，说明其有效，就标记为可达，如果不可达，则对其进行清除</p>
<p><strong>分代回收</strong></p>
<p>这种机制是典型的以空间换时间的技术。当对象被创建时标记为第0代，经过一次垃圾回收之后，余下的对象被标记为第1代，最高为第2代。0代触发将清理所有三代，1代触发会清理1,2代，2代触发后只会清理自己。</p>
<p>这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。</p>
]]></content>
  </entry>
  <entry>
    <title>python基础之作用域问题</title>
    <url>/2019/03/23/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>作用域</strong>：变量的生效范围，例如本地变量、全局变量描述的就是不同的生效范围。</p>
<p>python的作用域是静态的，变量被赋值、创建的位置决定了其被访问的范围，即变量作用域由其所在位置决定。</p>
<a id="more"></a>

<p>在Python中，使用一个变量时并不严格要求需要预先声明它，但是在真正使用它之前，它必须被绑定到某个<strong>内存对象</strong>(被定义、赋值)；这种变量名的绑定将在当前作用域中引入新的变量，同时屏蔽外层作用域中的同名变量。</p>
<p>来看一个小demo</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local</span>():</span></span><br><span class="line">    a = <span class="number">2</span> <span class="comment">#由于python不需要预先声明，因此在局部作用域中引入新的变量，而没有修改全局变量</span></span><br><span class="line">local()</span><br><span class="line">print(a)</span><br><span class="line">输出<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>首先在函数外定义了一个全局变量a，在local函数中修改a=2，由于没有用global声明，所以它并不会被修改，只是对a的重新赋值，并且只在函数内部有效。</p>
<h3 id="LEGB作用域"><a href="#LEGB作用域" class="headerlink" title="LEGB作用域"></a>LEGB作用域</h3><p>L-Local(function)；函数内的名字空间</p>
<p>E-Enclosing function locals；外部嵌套函数的名字空间(例如closure)</p>
<p>G-Global(module)；函数定义所在模块（文件）的名字空间</p>
<p>B-Builtin(Python)；Python内置模块的名字空间</p>
<ul>
<li><p>Local（局部）：在函数与类中，每当调用函数时都会创建一个局部作用域，局部变量域像一个栈，仅仅是暂时的存在，依赖创建该局部作用域的函数是否处于活动的状态； 默认情况下局部是无法修改全局变量的</p>
<p>要实现局部修改全局变量，有两种办法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#(1)增加global，nonlocal关键字</span></span><br><span class="line">a = [<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">local()</span><br><span class="line">print(a)</span><br><span class="line">输出[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">#(2)对于可变对象，如list，dict等，使用内置函数</span></span><br><span class="line"><span class="comment">#使用内置函数不需要global声明，若是使用list += [1,2]则需要声明</span></span><br><span class="line">b = [<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local</span>():</span></span><br><span class="line">    b.append(<span class="number">2</span>)</span><br><span class="line">local()</span><br><span class="line">print(b)</span><br><span class="line">输出[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>global关键字声明修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量</li>
<li>nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，适用于函数嵌套的场景，内层函数修改外层函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误</li>
</ul>
</li>
<li><p><strong>Enclosed（嵌套）：一般出现在函数中嵌套了一个函数，在外围的函数中的作用域；主要目的是实现闭包</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local</span>(<span class="params">i</span>):</span></span><br><span class="line">    a = [] <span class="comment">#此处a在add函数的嵌套作用域内</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">        a.append(i)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> add</span><br><span class="line">temp = local(<span class="number">1</span>)</span><br><span class="line">print(temp())</span><br><span class="line">输出[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Global（全局）</strong>：模块文件顶层声明的变量具有全局作用域，从外部开来，模块的全局变量就是一个模块对象的属性；仅限于单个模块文件中；</p>
</li>
<li><p><strong>Built-in（内置）</strong>：系统内解释器定义的变量，如预定义在builtin 模块内的变量；解释器在则在，解释器亡则亡；</p>
</li>
</ul>
<p><strong>当在函数中使用未确定的变量名时，Python会按照优先级依次搜索4个作用域，以此来确定该变量名的意义。</strong></p>
<p><strong>搜索变量名的优先级：L&gt;E&gt;G&gt;B</strong></p>
]]></content>
  </entry>
  <entry>
    <title>python实现简单工厂模式</title>
    <url>/2019/04/01/python%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式之简单工厂模式："><a href="#设计模式之简单工厂模式：" class="headerlink" title="设计模式之简单工厂模式："></a>设计模式之简单工厂模式：</h2><h3 id="模式定义："><a href="#模式定义：" class="headerlink" title="模式定义："></a>模式定义：</h3><p>定义一个工厂类，它可以根据参数的不同返回不同类的实例，在简单工厂模式中用于被创建实例 的方法通常为静态(static)方法,因此简单工厂模式又被成为静态工厂方法(Static Factory Method)。</p>
<a id="more"></a>
<p>需要什么，只需要传入一个正确的参数，就可以获取所需要的对象，而无需知道其实现过程</p>
<h3 id="模式结构："><a href="#模式结构：" class="headerlink" title="模式结构："></a>模式结构：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单工厂模式包含如下角色：</span><br><span class="line">Factory：工厂角色</span><br><span class="line">Product：抽象产品角色</span><br><span class="line">ConcreteProduct：具体产品角色</span><br></pre></td></tr></table></figure>

<h3 id="简单工厂："><a href="#简单工厂：" class="headerlink" title="简单工厂："></a>简单工厂：</h3><p>首先，我们来看一个简单工厂的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asus</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    华硕</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ASUS&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dell</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    戴尔</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELL&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们有两款电脑产品，分别是戴尔和华硕，如果没有“工厂”来生产它们，我们就要在代码中自己进行实例化，如：</span></span><br><span class="line">asus = Asus()</span><br><span class="line">dell = Dell()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但现实中，你可能会面对很多电脑产品，而且每个产品的构造参数还不一样，这样在创建实例时会遇到麻烦。这时就可以构造一个“简单工厂”把所有产品实例化的过程封装在里面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    简单工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;asus&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> Asus()</span><br><span class="line">        <span class="keyword">elif</span> name == <span class="string">&#x27;dell&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> Dell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simple_factory = SimpleCarFactory()</span><br><span class="line">asus = simple_factory.product_car(<span class="string">&#x27;asus&#x27;</span>)</span><br><span class="line">dell = SimpleCarFactory.product_car(<span class="string">&#x27;dell&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你会发现，有了SimpleCarFactory类后，就可以通过向固定的接口传入参数获得想要的对象实例</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li>
<li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li>
<li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>redis基础</title>
    <url>/2019/01/10/redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="redis基础"><a href="#redis基础" class="headerlink" title="redis基础"></a>redis基础</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p>
<a id="more"></a>

<p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<h3 id="2-五大数据类型"><a href="#2-五大数据类型" class="headerlink" title="2. 五大数据类型"></a>2. 五大数据类型</h3><p>在学习redis之前，我们先要了解一下redis本身的五大数据结构，首先，redis中所有数据结构都以唯一的key字符串作为名称，通过这个唯一的key来获取对应的value</p>
<ol>
<li>String: 字符串，是redis中最基本的数据类型，一个key对应一个value。string类型是二进制安全的，意思是redis的string可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</li>
<li>List：列表，底层为双向链表，左右两边都可以插入和删除数据，插入和删除的时间复杂度是O(1),索引的时间复杂度为O(n)</li>
<li>Hash：字典，哈希表，是一个键值(key=&gt;value)对集合。应用场景：假设有多个用户及对应的用户信息，可以用来存储以用户ID为key，将用户信息序列化为比如json格式做为value进行保存。</li>
<li>Set：集合，redis中的set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</li>
<li>Sorted Set：有序集合，它跟集合有着必然的联系，保留了集合不能有重复数据的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个double类型的分数，作为排序的依据</li>
</ol>
<h3 id="3-相关命令"><a href="#3-相关命令" class="headerlink" title="3. 相关命令"></a>3. 相关命令</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 操作管理</span></span><br><span class="line">DEL key							如果存在删除键</span><br><span class="line">DUMP key						返回存储在指定键的值的序列化版本</span><br><span class="line">EXISTS key						此命令检查该键是否存在</span><br><span class="line">EXPIRE key seconds				指定键的过期时间</span><br><span class="line">TYPE key						返回存储在键的数据类型的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串相关</span></span><br><span class="line"><span class="built_in">set</span> key value		设置key=value</span><br><span class="line">get key				获取键key对应的值</span><br><span class="line">getset key value	设置键的字符串值，并返回旧值</span><br><span class="line">setex key value		设置键的值，只有当该键不存在</span><br><span class="line">MSET key value [key value...]	设置多个键和多个值</span><br><span class="line"><span class="keyword">del</span> key				如果存在删除键</span><br><span class="line">exists key			查询键是否存在</span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> <span class="built_in">round</span> <span class="number">11</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get <span class="built_in">round</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; getset <span class="built_in">round</span> <span class="number">22</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get <span class="built_in">round</span></span><br><span class="line"><span class="string">&quot;22&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> <span class="built_in">round</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希相关</span></span><br><span class="line">HSET key field value 	设置对象指定字段的值</span><br><span class="line">HGET key field 			获取对象中该field属性域的值</span><br><span class="line">HDEL key field			删除对象的一个或几个属性域，不存在的属性将被忽略</span><br><span class="line">HLEN key 				获取对象的所有属性字段的总数</span><br><span class="line">HKEYS key 				获取对象的所有属性字段</span><br><span class="line">HVALS key 				获取对象的所有属性值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>






]]></content>
  </entry>
  <entry>
    <title>redis集群+哨兵模式</title>
    <url>/2020/11/16/redis%E9%9B%86%E7%BE%A4-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h4 id="为什么要用集群："><a href="#为什么要用集群：" class="headerlink" title="为什么要用集群："></a>为什么要用集群：</h4><p>通常，为了提高网站响应速度，总是把热点数据保存在内存中而不是直接从后端数据库中读取。</p>
<a id="more"></a>

<p>Redis是一个很好的Cache工具。大型网站应用，热点数据量往往巨大，几十G上百G是很正常的事儿。</p>
<p>由于内存大小的限制，使用一台Redis实例显然无法满足需求，这时就需要使用多台Redis(集群)作为缓存数据库。才能在用户请求时快速的进行响应。</p>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>我们在刚接触docker的时候，简单弄了一个所谓的集群，其实，在docker中开启一个6380端口的redis之后，宿主机6379端口也启动redis服务，理论上来讲，这两个redis并不叫集群，为什么呢，因为它只是简单的两台服务器，没有任何关系，数据不会共享。</p>
<p>不管是reids集群，或者mysql、mongo，都有一个最主要的特质：<strong>数据共享</strong></p>
<p>举个栗子：</p>
<p>比如连锁店、或者大型超市or酒店，都可以办会员卡，只要办理了一家连锁店的会员卡，就可以在这个品牌旗下的多家店面使用，这就相当于是<strong>数据共享</strong>的机制。如果数据不共享，那顾客就会很麻烦，大费周章，也就失去了连锁的意义，那么回到redis中也是一样，多台服务数据不共享，就不知道数据具体在哪台机器上。</p>
<h4 id="redis主从（高负载）"><a href="#redis主从（高负载）" class="headerlink" title="redis主从（高负载）"></a>redis主从（高负载）</h4><p><img src="https://img-blog.csdnimg.cn/20201203213123397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>几乎所有的数据库，做集群的话，它的共享方式基本都是大同小异：主从</p>
<p>首先，有一台主服务器<strong>master</strong>，一台或者多台从服务器<strong>slave</strong>.(图中是有一主三从)。一般情况下，一主一从和一主多从的原理是一样的，区别就在于从机的数量。</p>
<p>原理：所有的读写操作全部连master，但实际上，当我们写入master的时候，它能瞬间把你写入的数据同步到所有从机，当读数据的时候，会自动分流。自动从一台负载比较低的服务器获取数据，以往没有集群的时候，读写都在一台机器上，在高并发的情况下，这一台机器未必撑得住，所以产生了集群。</p>
<p>举例：当人体受到伤害时，物品越锋利，承受的疼痛就会越大，是因为受力面积小，可以理解为受力点为一台机器，承受不了高并发，若是部署了多台机器，就可以扛得住高负载。</p>
<h4 id="哨兵模式（高可用）"><a href="#哨兵模式（高可用）" class="headerlink" title="哨兵模式（高可用）"></a>哨兵模式（高可用）</h4><p>相信看到这儿，不太了解集群的伙伴已经对它有了一个新的理解了，有利就有弊，部署了集群之后，还会不会产生什么问题，想没想过<strong>主机宕机</strong>这种的情况，是不是恍然大悟</p>
<p>机器毕竟是机器，什么情况都可能发生，万一发生了，带来的后果对企业级乃是灾难性的。一般的公司都会有一套容灾机制：<strong>sentinel</strong></p>
<blockquote>
<p>概念：哨兵模式是redis 高可用 的实现方式之一使用一个或者多个哨兵(Sentinel)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。</p>
</blockquote>
<p>其实很简单，哨兵本质上有两个作用：</p>
<ul>
<li><p>监控</p>
<p>每个哨兵都是实例，可以理解为进程，是单独存在的，作用就是监控各个数据节点的服务器，监控它的链接数，网络请求数，收集数据，查看节点的健康状态。若是其中有一台服务器故障了，哨兵就会第一时间监控到，并根据提前设计好的方案做出相应的操作（例：推送消息）</p>
<p>实际上，每个哨兵节点每秒通过ping去进行心跳监测（包括所有redis实例和sentinel同伴），并根据回复判断节点是否在线。</p>
</li>
<li><p>选举</p>
<p>主机永远只有一台，刚刚讨论的是从机宕机，其实并没有太大的影响，关键是主机挂掉怎么办，此时哨兵又派上用场了。它会根据提前收集好的数据来判断哪一台从机是最健康的，会将选举出来的节点升级为主节点。</p>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>写到这里对自己收获还是很大的，有时间再聊聊redis集群的搭建和设置哨兵模式</p>
]]></content>
  </entry>
  <entry>
    <title>snowflake雪花算法</title>
    <url>/2020/11/02/snowflake%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着大型网站的各种高并发访问、海量数据处理等场景越来越多如何实现网站的高可用、可扩展、安全等目标就显得越来越重要。为了解决这样一系列问题，大型网站的架构也在</p>
<a id="more"></a>

<p>不断发展。提高大型网站的高可用架构，不得不提的就是分布式。但凡说起分布式系统，我们肯定会对一些海量级的业务进行拆分，但是一旦涉及到分库分表，就会引申出分布式系统中唯一主键ID的生成问题。</p>
<p>这里介绍一下唯一ID算法Snowflake，它是Twitter公司提出来的算法。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Snowflake算法生成id的结果是一个64bit大小的整数，它的结构如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201203003822326.png#pic_center"></p>
<ul>
<li>1位标识符：始终是0</li>
<li>41位时间戳：精确到毫秒，也就是说最大可使用的年限是69年。</li>
<li>10位机器位：能部署在1024台机器节点来生成ID。</li>
<li>12位序列号：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号</li>
</ul>
<p>Snowflake可以保证：</p>
<ul>
<li>所有生成的id按时间趋势递增</li>
<li>整个分布式系统内不会产生重复id</li>
</ul>
<h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><p>这里使用python来生成snowflake唯一id</p>
<p>首先安装库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pysnowflake</span><br></pre></td></tr></table></figure>

<p>安装完成后，就可以在本地命令行启动snowflake服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snowflake_start_server --worker&#x3D;1</span><br></pre></td></tr></table></figure>

<p>这里的worker就是当前节点的标识，可以打印出当前客户端使用的snowflake的服务信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> snowflake.client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">print(snowflake.client.get_guid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res：&#123;<span class="string">&#x27;dc&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;worker&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;timestamp&#x27;</span>: <span class="number">1606922365854</span>, <span class="string">&#x27;last_timestamp&#x27;</span>: <span class="number">1606922357628</span>, <span class="string">&#x27;sequence&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;sequence_overload&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;errors&#x27;</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>根据服务生成snowflake唯一id</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取订单id,19位纯整型，整型读取效率最高</span></span><br><span class="line">print(snowflake.client.get_guid())</span><br><span class="line"></span><br><span class="line">res：<span class="number">4431873127680577537</span></span><br></pre></td></tr></table></figure>

<p>多打印几遍，你会发现这些id很明显带有递增的连续性，那么，假设我搭建了上千个节点的分布式系统，此时接口接到参数id，我要怎么判断该id的订单信息存储在哪个节点中呢？</p>
<p>利用逆向思维，我们可以将生成的19的id反着解析成64bit二进制，因为从snowflake的算法结构入手，本身就是二进制转换十进制的整型</p>
<p>首先将其转换为二进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">bin</span>(<span class="number">4431873127680577537</span>))</span><br><span class="line"><span class="number">0b11110110000001001011010010000011101001000000000001000000000001</span></span><br></pre></td></tr></table></figure>

<p>可以看到这个就是snowflake的组成结构了，第一位是标识符，永远为0，此后是41位的时间戳，紧接着10位的节点标识码，最后12位的递增序列。我们需要找到10位节点标识码中的后5位，这5位就是某个节点的存储标识，但是它目前是二进制，我们再将它转换为十进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">int</span>(<span class="string">&#x27;00001&#x27;</span>, <span class="number">2</span>))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以看到，转换结果显示该id存储在节点1的数据库中，如此就具备了相当强的业务属性，通过反推逻辑我们可以快速准确的定位到数据的具体存储位置从而进行查询。</p>
]]></content>
  </entry>
  <entry>
    <title>vue-drag-verify验证组件</title>
    <url>/2020/04/19/vue-drag-verify%E9%AA%8C%E8%AF%81%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="vue-drag-verify滑块验证组件"><a href="#vue-drag-verify滑块验证组件" class="headerlink" title="vue-drag-verify滑块验证组件"></a>vue-drag-verify滑块验证组件</h2><p>在这里分享一个用于登录验证的vue组件，这是一个基于vue2.0的验证组件，可以自定义背景色及字体等样式</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20201125230214677.png#pic_center"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通过npm安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install vue-drag-verify --save</span><br></pre></td></tr></table></figure>

<h3 id="插件应用"><a href="#插件应用" class="headerlink" title="插件应用"></a>插件应用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;drag-verify :width&#x3D;&quot;width&quot; </span><br><span class="line">             :height&#x3D;&quot;height&quot; </span><br><span class="line">             :text&#x3D;&quot;text&quot; </span><br><span class="line">             :success-text&#x3D;&quot;successText&quot; </span><br><span class="line">             :background&#x3D;&quot;background&quot; </span><br><span class="line">             :progress-bar-bg&#x3D;&quot;progressBarBg&quot; </span><br><span class="line">             :completed-bg&#x3D;&quot;completedBg&quot; </span><br><span class="line">             :handler-bg&#x3D;&quot;handlerBg&quot; </span><br><span class="line">             :handler-icon&#x3D;&quot;handlerIcon&quot; </span><br><span class="line">             :text-size&#x3D;&quot;textSize&quot; </span><br><span class="line">             :success-icon&#x3D;&quot;successIcon&quot; </span><br><span class="line">             :circle&#x3D;&quot;getShape&quot;&gt;</span><br><span class="line">&lt;&#x2F;drag-verify&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import dragVerify from &#39;vue-drag-verify&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;app&#39;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    dragVerify</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组件参数"><a href="#组件参数" class="headerlink" title="组件参数"></a>组件参数</h3><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>Number</td>
<td>200</td>
<td>组件的宽度</td>
</tr>
<tr>
<td>height</td>
<td>Number</td>
<td>60</td>
<td>组件的高度</td>
</tr>
<tr>
<td>text</td>
<td>String</td>
<td>swiping to the right side</td>
<td>提示信息文字</td>
</tr>
<tr>
<td>successText</td>
<td>String</td>
<td>success</td>
<td>验证通过时的提示信息文字</td>
</tr>
<tr>
<td>progressBarBg</td>
<td>String</td>
<td>#FFFF99</td>
<td>拖拽过程中的背景颜色</td>
</tr>
<tr>
<td>handlerBg</td>
<td>String</td>
<td>#fff</td>
<td>拖拽按钮的背景色</td>
</tr>
<tr>
<td>circle</td>
<td>Boolean</td>
<td>true</td>
<td>设为true,组件为圆形按钮，否则为长方形</td>
</tr>
</tbody></table>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>passcallback</td>
<td>验证通过</td>
</tr>
<tr>
<td>passfail</td>
<td>验证失败</td>
</tr>
<tr>
<td>refresh</td>
<td>点击刷新回调</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>vue定义全局变量</title>
    <url>/2019/01/29/vue%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="vue项目中定义全局变量"><a href="#vue项目中定义全局变量" class="headerlink" title="vue项目中定义全局变量"></a>vue项目中定义全局变量</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在项目中，经常会复用一些变量和函数，比如用户登录的token，axios请求的url。假设每次axios请求都要写一遍<a href="http://localhost:8000/xxx/%EF%BC%8C%E9%82%A3%E4%B9%88%E9%A1%B9%E7%9B%AE%E5%9C%A8%E6%9C%80%E5%90%8E%E9%83%A8%E7%BD%B2%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E5%B0%86%E6%AF%8F%E4%B8%AAurl%E9%83%BD%E6%94%B9%E4%B8%80%E9%81%8D%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%BC%9A%E9%9D%9E%E5%B8%B8%E4%B8%8D%E6%96%B9%E4%BE%BF%EF%BC%8C%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%B0%B1%E5%BE%88%E5%BF%85%E8%A6%81%E4%BA%86">http://localhost:8000/xxx/，那么项目在最后部署时，需要将每个url都改一遍，这样会非常不方便，定义全局变量就很必要了</a></p>
<a id="more"></a>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用模块（.js或.vue组件）来管理全局变量，最后使用export导出，当其他地方需要使用时，用import导入该模块</p>
<h3 id="1-使用全局变量专用模块，挂载到main-js文件上面"><a href="#1-使用全局变量专用模块，挂载到main-js文件上面" class="headerlink" title="1. 使用全局变量专用模块，挂载到main.js文件上面"></a>1. 使用全局变量专用模块，挂载到main.js文件上面</h3><h4 id="1-1-定义全局变量"><a href="#1-1-定义全局变量" class="headerlink" title="1.1 定义全局变量"></a>1.1 定义全局变量</h4><p><code>Global.vue</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">const</span> base_url = <span class="string">&#x27;http://localhost:8000&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    base_url,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>模块里的变量用export导出去，当其他地方需要使用时，引入模块便可。</p>
<h4 id="1-2-使用全局变量"><a href="#1-2-使用全局变量" class="headerlink" title="1.2 使用全局变量"></a>1.2 使用全局变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import global from &#39;@&#x2F;components&#x2F;Global&#39;  &#x2F;&#x2F; 引入模块</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            base_url: global.base_url,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-全局变量模块挂载到Vue-prototype上"><a href="#2-全局变量模块挂载到Vue-prototype上" class="headerlink" title="2. 全局变量模块挂载到Vue.prototype上"></a>2. 全局变量模块挂载到Vue.prototype上</h3><p>Global.vue组件同上，在项目入口的<code>src\main.js</code>中配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> global_ <span class="keyword">from</span> <span class="string">&#x27;./components/Global&#x27;</span></span><br><span class="line">Vue.prototype.GLOBAL = global_</span><br></pre></td></tr></table></figure>

<p>挂载之后，在需要引用全局变量的模块处，不需在导入全局变量模块，而是直接用<strong>this</strong>就可以引用了，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            base_url: <span class="built_in">this</span>.GLOBAL.base_url</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法一跟方法二的主要区别是：方法二全局只需要导入一次就可以，简单方便</p>
]]></content>
  </entry>
  <entry>
    <title>vue安装</title>
    <url>/2018/11/01/vue%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-vue核心概念"><a href="#1-vue核心概念" class="headerlink" title="1. vue核心概念"></a>1. vue核心概念</h2><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。</p>
<a id="more"></a>

<p>Vue 只关注视图层， 采用自底向上增量开发的设计。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<p>官方文档：<a href="http://vuejs.org/v2/guide/syntax.html">http://vuejs.org/v2/guide/syntax.html</a></p>
<p>中文文档: <a href="https://cn.vuejs.org/v2/guide/syntax.html">https://cn.vuejs.org/v2/guide/syntax.html</a></p>
<h2 id="2-vue-js安装"><a href="#2-vue-js安装" class="headerlink" title="2. vue.js安装"></a>2. vue.js安装</h2><h4 id="2-1-安装node-js环境（npm包管理工具）"><a href="#2-1-安装node-js环境（npm包管理工具）" class="headerlink" title="2.1 安装node.js环境（npm包管理工具）"></a>2.1 安装node.js环境（npm包管理工具）</h4><p>从<a href="https://nodejs.org/en/">node.js官网</a>下载并安装node，安装过程很简单，一直点下一步就ok了</p>
<p>安装完成之后，进入命令行窗口，输入node -v命令，查看node的版本</p>
<p> <img src="/node%E7%89%88%E6%9C%AC.jpg" alt="node版本"></p>
<h4 id="2-2-安装vue-cli脚手架构建工具（必须在全局中进行安装）"><a href="#2-2-安装vue-cli脚手架构建工具（必须在全局中进行安装）" class="headerlink" title="2.2 安装vue-cli脚手架构建工具（必须在全局中进行安装）"></a>2.2 安装vue-cli脚手架构建工具（必须在全局中进行安装）</h4><ol>
<li><p>在命令行中运行命令 npm install -g vue-cli ，然后等待安装完成。</p>
</li>
<li><p>是否安装成功：vue -V</p>
</li>
</ol>
<h4 id="2-3-切换国内镜像源"><a href="#2-3-切换国内镜像源" class="headerlink" title="2.3 切换国内镜像源"></a>2.3 切换国内镜像源</h4><ol>
<li><p>使用cnpm</p>
<ul>
<li>由于有些npm资源被屏蔽或者是国外资源的原因，经常会导致npm安装依赖包的时候失败，所以我们还需要npm的国内镜像—-cnpm.</li>
<li>在命令行中输入npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a></li>
</ul>
</li>
<li><p>将npm切换为淘宝镜像源</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm set registry https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line">指定源</span><br><span class="line"></span><br><span class="line">npm config list</span><br><span class="line">查看npm信息</span><br><span class="line"></span><br><span class="line">npm install npm -g</span><br><span class="line">升级npm</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果出现任何关于node依赖的问题导致服务无法启动，执行npm install无法解决的，则安装rimraf,然后进入项目目录下，执行rimraf node_modules 删除后，重新执行 npm install 安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除node_modules</span><br><span class="line"></span><br><span class="line">npm install rimraf -g</span><br><span class="line"></span><br><span class="line">rimraf node_modules</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-4-创建vue项目"><a href="#2-4-创建vue项目" class="headerlink" title="2.4 创建vue项目"></a>2.4 创建vue项目</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化项目</span></span><br><span class="line">vue init webpack vue01  <span class="comment"># 在文件夹对应的cmd窗口使用， 输完回车</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 接下来选择配置项目信息</span></span><br><span class="line">? Project name (vue01)  #项目名称 默认回车即可</span><br><span class="line">? Project description (A Vue.js project)  # 项目描述 默认回车即可</span><br><span class="line">? Author   # 作者  默认回车即可</span><br><span class="line"></span><br><span class="line">? Vue build (Use arrow keys)    # 打包项目选项 默认回车即可</span><br><span class="line">? Install vue-router? (Y/n)   # 是否安装路由  输入y</span><br><span class="line">? Use ESLint to lint your code? (Y/n)  # 是否使用eslint检测代码， 输入n</span><br><span class="line">? Set up unit tests (Y/n)   # 是否使用测试单元    输入 n</span><br><span class="line">? Setup e2e tests with Nightwatch?  #   输入n</span><br><span class="line">? Should we run `npm install` for you after the project has been created? (recommended)</span><br><span class="line">    ❯ Yes, use NPM  <span class="comment"># 是否使用npm包管理工具</span></span><br><span class="line">    Yes, use Yarn  <span class="comment"># 是否使用yarn包管理工具</span></span><br><span class="line">    No, I will handle that myself  <span class="comment"># 不，我使用我自己的工具，想使用cnpm选第三个选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 进入项目文件夹，在终端安装必备的包</span></span><br><span class="line">cd vue01  <span class="comment"># 首先进入项目文件夹</span></span><br><span class="line">npm install  <span class="comment"># 如果上面选的是第三个选项， 这一步是必须的，使用cnpm工具，安装一些必备的项目包, </span></span><br><span class="line">            <span class="comment"># 如果上面选的是npm，这一步没必要，当然多运行一遍，也没问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 在终端运行项目</span></span><br><span class="line">npm run dev  <span class="comment"># 两个命令任意一个即可，启动项目</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>三方聊天机器人</title>
    <url>/2020/07/11/%E4%B8%89%E6%96%B9%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<p>聊天机器人（Chatterbot）是经由对话或文字进行交谈的计算机程序。目前市面上提供三方api的机器人不胜枚举：微软小冰、腾讯闲聊、青云客机器人等等</p>
<a id="more"></a>

<h4 id="青云客机器人"><a href="#青云客机器人" class="headerlink" title="青云客机器人"></a>青云客机器人</h4><p><strong>简介</strong></p>
<p>完全免费，支持功能：天气、翻译、藏头诗、笑话、歌词、计算、域名信息/备案/收录查询、IP查询、手机号码归属、人工智能聊天</p>
<p>不用注册，不用申请key，拿来就用！</p>
<p><strong>实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qingyunke</span>(<span class="params">msg</span>):</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">&quot;http://api.qingyunke.com/api.php?key=free&amp;appid=0&amp;msg=%s&quot;</span> % (urllib.parse.quote(msg))</span><br><span class="line"></span><br><span class="line">    html = requests.get(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> html.json()[<span class="string">&quot;content&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msg = <span class="string">&quot;下午好&quot;</span></span><br><span class="line"></span><br><span class="line">print(qingyunke(msg))</span><br></pre></td></tr></table></figure>

<h4 id="微软小冰"><a href="#微软小冰" class="headerlink" title="微软小冰"></a>微软小冰</h4><p><strong>简介</strong></p>
<p>微软小冰是领先的跨平台人工智能机器人。微软小冰注重人工智能在拟合人类情商维度的发展，强调人工智能情商，而非任务完成在人机交互中的基础价值。</p>
<p>需要先<strong>领养小冰</strong>！通过<strong>微博</strong>关注<strong>微软小冰</strong>，并向她发送一条消息，点击她回的链接进行领养。</p>
<p><img src="https://img-blog.csdnimg.cn/20201115212031713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>点击链接后，打开控制台，在<strong>Cookie</strong>界面找到<strong>SUB</strong>值</p>
<p><img src="https://img-blog.csdnimg.cn/2020111521211195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>随便发一条消息给小冰，在<strong>new.json</strong>界面找到<strong>source</strong>值和<strong>uid</strong>值</p>
<p><img src="https://img-blog.csdnimg.cn/2020111521213894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p><strong>实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xiaobing</span>(<span class="params">msg</span>):</span></span><br><span class="line">    uid = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    source = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    SUB = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    url_send = <span class="string">&#x27;https://api.weibo.com/webim/2/direct_messages/new.json&#x27;</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;text&#x27;</span>: msg,</span><br><span class="line">        <span class="string">&#x27;uid&#x27;</span>: uid,</span><br><span class="line">        <span class="string">&#x27;source&#x27;</span>: source</span><br><span class="line">    &#125;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;SUB=&#x27;</span>+SUB,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://api.weibo.com/chat/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.post(url_send, data=data, headers=headers).json()</span><br><span class="line">    sendMsg = response[<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        url_get = <span class="string">&#x27;https://api.weibo.com/webim/2/direct_messages/conversation.json?uid=&#123;&#125;&amp;source=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(uid, source)</span><br><span class="line">        response = requests.get(url_get, headers=headers).json()</span><br><span class="line">        getMsg = response[<span class="string">&#x27;direct_messages&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> sendMsg == getMsg:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getMsg</span><br><span class="line">            </span><br><span class="line">msg = <span class="string">&#x27;下午好&#x27;</span></span><br><span class="line">print(<span class="string">&quot;原话&gt;&gt;&quot;</span>, msg)</span><br><span class="line">res = xiaobing(msg)</span><br><span class="line">print(<span class="string">&quot;小冰&gt;&gt;&quot;</span>, res)</span><br></pre></td></tr></table></figure>

<h4 id="腾讯闲聊"><a href="#腾讯闲聊" class="headerlink" title="腾讯闲聊"></a>腾讯闲聊</h4><p><a href="https://ai.qq.com/console/home">https://ai.qq.com/console/home</a></p>
<p><strong>创建应用</strong></p>
<p> <img src="https://img-blog.csdnimg.cn/20201115212205470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>拿到APPID和APPKEY</p>
<p><img src="https://img-blog.csdnimg.cn/2020111521223072.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p><strong>实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tencent</span>(<span class="params">msg</span>):</span></span><br><span class="line">    APPID = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    APPKEY = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    url = <span class="string">&#x27;https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat&#x27;</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;app_id&#x27;</span>: APPID,</span><br><span class="line">        <span class="string">&#x27;time_stamp&#x27;</span>: <span class="built_in">str</span>(<span class="built_in">int</span>(time.time())),</span><br><span class="line">        <span class="string">&#x27;nonce_str&#x27;</span>: <span class="string">&#x27;&#x27;</span>.join(random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>)),</span><br><span class="line">        <span class="string">&#x27;session&#x27;</span>: <span class="string">&#x27;10000&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;question&#x27;</span>: msg.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sign_before = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(params):</span><br><span class="line">        <span class="comment"># 键值拼接过程value部分需要URL编码，URL编码算法用大写字母，例如%E8。quote默认大写。</span></span><br><span class="line">        sign_before += <span class="string">&#x27;&#123;&#125;=&#123;&#125;&amp;&#x27;</span>.<span class="built_in">format</span>(key, urllib.parse.quote(params[key], safe=<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">        <span class="comment"># 将应用密钥以app_key为键名，拼接到字符串sign_before末尾</span></span><br><span class="line">    sign_before += <span class="string">&#x27;app_key=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(APPKEY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对字符串sign_before进行MD5运算，得到接口请求签名</span></span><br><span class="line">    sign = hashlib.md5(sign_before.encode(<span class="string">&#x27;UTF-8&#x27;</span>)).hexdigest().upper()</span><br><span class="line">    params[<span class="string">&#x27;sign&#x27;</span>] = sign</span><br><span class="line">    <span class="comment"># print(params)</span></span><br><span class="line">    html = requests.post(url, data=params).json()</span><br><span class="line">    <span class="keyword">return</span> html[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;answer&#x27;</span>]</span><br><span class="line"></span><br><span class="line">msg= <span class="string">&#x27;下午好&#x27;</span></span><br><span class="line">res = tencent(msg)</span><br><span class="line">print(<span class="string">&quot;腾讯&gt;&gt;&quot;</span>, res)</span><br></pre></td></tr></table></figure>




]]></content>
  </entry>
  <entry>
    <title>倒排索引</title>
    <url>/2020/02/23/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="倒排索引的初衷"><a href="#倒排索引的初衷" class="headerlink" title="倒排索引的初衷"></a>倒排索引的初衷</h3><p><strong>倒排索引，它也是索引。索引，初衷都是为了快速检索到你要的数据。</strong></p>
<a id="more"></a>

<p>说到倒排索引，一定知道MySQL的索引，如果对某一个字段加了索引，一般来说查询该字段速度是可以有显著的提升。 每种数据库都有自己要解决的问题（或者说擅长的领域），对应的就有自己的数据结构，而不同的使用场景和数据结构，需要用不同的索引，才能起到最大化加快查询的目的。 对 Mysql 来说，是 B+ 树，对 Elasticsearch 来说，是倒排索引。</p>
<p>简单来说，ES引入倒排索引就是为了加速查询和搜索速度。</p>
<p>同样是提高速度，ES用倒排索引，而mysql要用B+tree</p>
<p><strong>举个栗子</strong></p>
<p>说倒排索引之前，还是先来看看正排索引是什么吧</p>
<p>我现在有一本书，如果我需要快速找到想看的章节怎么办？</p>
<p>看目录呀，书的目录就是书的内容的简单索引</p>
<p>再举一个倒排索引的例子：</p>
<p>有一天你走在大街上，突然听到一首你从来没听过但又觉得特别好听的歌，这个时候你记住的只是一些歌词，你是否会记住其中的几句歌词，然后去通过这些零星的歌词取搜索歌名。</p>
<p>其实这两个例子可以很形象的比喻正排索引和倒排索引。</p>
<p><strong>倒排索引创建索引的流程</strong></p>
<ol>
<li>首先把所有的原始数据进行编号，形成文档列表</li>
<li>把文档数据进行分词，得到很多的词条，以词条为索引。保存包含这些词条的文档的编号信息。</li>
</ol>
<p><strong>搜索的过程</strong></p>
<ol>
<li><p>当用户输入任意的词条时，首先对用户输入的数据进行分词，得到用户要搜索的所有词条，然后拿着这些词条去倒排索引列表中进行匹配。找到这些词条就能找到包含这些词条的所有文档的编号。</p>
</li>
<li><p>然后根据这些编号去文档列表中找到文档</p>
</li>
</ol>
<p>数据库的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explan 计划任务 ：可以自动检索这条语句的性能</span><br><span class="line">explan select * from user;</span><br></pre></td></tr></table></figure>

<p>不要无脑建索引，坚持最左前缀索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unique 唯一索引</span><br><span class="line"></span><br><span class="line">Normal 普通索引（加大查询效率）</span><br><span class="line"></span><br><span class="line">Full Text 全文索引</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>初识人工智能</title>
    <url>/2020/06/14/%E5%88%9D%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
    <content><![CDATA[<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p><strong>人工智能</strong>（英语：artificial intelligence，缩写为<strong>AI</strong>），让机器具备人的特性，是一个非常广的领域。举个例子：</p>
<a id="more"></a>

<ol>
<li><strong>聊天机器人</strong>，回复你消息的并不是人类，而是机器，但是让你觉得它就是一个人类。</li>
<li><strong>自动驾驶</strong>领域，其实是辅助驾驶，可以自动识别路况，来帮你驾驶。所谓的自动驾驶，还不是特别成熟，需要慎用。</li>
</ol>
<p><strong>机器学习</strong>是人工智能的一个分支，是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。机器一旦训练完成，它的准确率可以达到百分之90以上，会比人的效率高很多。</p>
<h3 id="聊天机器人"><a href="#聊天机器人" class="headerlink" title="聊天机器人"></a>聊天机器人</h3><p><strong>聊天机器人，即会聊天的机器人，你能像跟人聊天的方式，与它聊天（机器与人的区别在于人具有理解能力，有情感会思考）</strong></p>
<p><strong>当前聊天机器人用到的技术</strong></p>
<p>机器学习和深度学习：机器学习技术属于基础技术，比如说分类算法可以用于做用户的意图分类和情感分类；语言模型可以用于筛选语音识别后的句子是否通顺；聚类算法可以用于做用户的行为习惯分析等等。随着数据量越来越多，可以发挥深度学习的优势，更进一步提升聊天机器人的基础技术能力。</p>
<h5 id="深度学习框架"><a href="#深度学习框架" class="headerlink" title="深度学习框架"></a>深度学习框架</h5><ol>
<li><p><strong>TensorFlow</strong>：谷歌的Tensorflow——可以说是当今最流行的深度学习框架。Gmail、Uber、Airbnb、Nvidia和其他许多知名品牌都在使用它。作为当今主流和头号的DL框架，在TF身上共存了受欢迎程度和高效率。</p>
<p>python是处理TensorFlow的最方便的客户端语言。不过，JavaScript、C++、Java、Go、C#和Julia也提供了实验性的交互界面。</p>
<p>TF背后有谷歌的支持，它的开发和维护就有坚实的后盾，用户不必担心刚学会TF这个框架它就下架，因此投资时间和资源来学习它是有意义的。</p>
</li>
<li><p><strong>Keras</strong>：是用于构建和训练深度学习模型的 TensorFlow 高阶 API。利用此 API，可实现快速原型设计、先进的研究和生产。</p>
<p>Keras是一个编写精美的API。API的功能特性可以完全帮助用户构建更多新奇复杂的应用。同时，Keras不会阻止对底层框架的访问。</p>
<p>Keras编写的代码更加可读和简洁。</p>
<p>使用Python生成器的Keras模型序列化/反序列化API、回调和数据流已经非常成熟。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>如何基于ECharts的数据可视化实现综合信息分析决策系统</title>
    <url>/2020/09/26/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EECharts%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E7%8E%B0%E7%BB%BC%E5%90%88%E4%BF%A1%E6%81%AF%E5%88%86%E6%9E%90%E5%86%B3%E7%AD%96%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="如何基于ECharts的数据可视化实现综合信息分析决策系统"><a href="#如何基于ECharts的数据可视化实现综合信息分析决策系统" class="headerlink" title="如何基于ECharts的数据可视化实现综合信息分析决策系统"></a>如何基于ECharts的数据可视化实现综合信息分析决策系统</h2><p>这篇文章我想与大家聊一聊如何快速上手“数据可视化”    神器–Echarts</p>
<a id="more"></a>

<p>假设我们公司今年盈利两千万，明年盈利三千万。你将这些数据给老板以及投资人看的时候，它是一堆阿拉伯数字，并起不到视觉上的震撼，所以你要是这么做了，那无疑是搬起石头砸自己的脚。这个时候我们就要对数据做可视化了，为了清晰有效地传递信息，数据可视化可以使用统计图形、图表、折线图以及其他工具。对于我们这些数据分析初学者来说，刚好ECharts就可以帮我们来实现这些需求，它是一个使用JavaScript实现的开源可视化库，涵盖各行业图标，废话不多说，我们一起来看。</p>
<p><strong>为什么要使用ECharts</strong></p>
<ul>
<li>简单、容易上手</li>
<li>几乎可以满足我们所有的开发需要</li>
<li>echarts 是国内做的最好的可视化库之一</li>
</ul>
<p><strong>如何在Vue项目中使用ECharts。</strong></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure>

<h4 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h4><p>我们安装完成之后，可以在main.js中全局引入echarts</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">&quot;echarts&quot;</span>;</span><br><span class="line">Vue.prototype.$echarts = echarts;</span><br></pre></td></tr></table></figure>

<h4 id="创建图表"><a href="#创建图表" class="headerlink" title="创建图表"></a>创建图表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;main&quot; style&#x3D;&quot;width: 600px;height:400px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;app&quot;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    drawChart() &#123;</span><br><span class="line">      &#x2F;&#x2F; 基于准备好的dom，初始化echarts实例</span><br><span class="line">      let myChart &#x3D; this.$echarts.init(document.getElementById(&quot;main&quot;));</span><br><span class="line">      &#x2F;&#x2F; 指定图表的配置项和数据</span><br><span class="line">      let option &#x3D; &#123;</span><br><span class="line">        title: &#123;</span><br><span class="line">          text: &quot;ECharts 入门示例&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        tooltip: &#123;&#125;,</span><br><span class="line">        legend: &#123;</span><br><span class="line">          data: [&quot;销量&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        xAxis: &#123;</span><br><span class="line">          data: [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        yAxis: &#123;&#125;,</span><br><span class="line">        series: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: &quot;销量&quot;,</span><br><span class="line">            type: &quot;bar&quot;,	&#x2F;&#x2F; 柱状图</span><br><span class="line">            data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;;</span><br><span class="line">      &#x2F;&#x2F; 使用刚指定的配置项和数据显示图表。</span><br><span class="line">      myChart.setOption(option);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.drawChart();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>不出意外的话，此时在页面中就可以看到你的效果了。</p>
<p><img src="https://img-blog.csdnimg.cn/20201126234935952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>只是这一点简单的代码，就已经实现了一个不可思议的功能，并且它还有很大的可操作性，只需要将方法中的一些固定参数进行动态绑定，如此简单，是不是会感到很惊讶，别着急，精彩的还在后面。</p>
<p>相信对理财投资比较感兴趣的伙伴都听说过<strong>K线图</strong>这个玩意，科普一下，K线图又称蜡烛图、日本线、阴阳线、棒线等，常用说法是“K线”，起源于日本十八世纪德川幕府时代（1603～1867年）的米市交易，用来计算米价每天的涨跌。这就是K线图的起源及背景，现在已经广泛应用于股票、期货、外汇，期权等证券市场。我们刚入门还是不做这么高大上的了，来做一个美元对人民币汇率兑换实时走势图，其实很好理解，就是一个折线图。先上效果</p>
<p><img src="https://media.giphy.com/media/864Icf413pw4tkbVem/giphy.gif"></p>
<p>大致效果就是这样的，它是可以一直动态渲染的，我只给它设定了5个时间段的汇率信息，由于是用来测试，方便查阅效果，在这里我将定时设的短了一点。</p>
<p>那它的需求是什么呢，就好比用户打开我这个页面，需要查看实时汇率，比如每隔一分钟动态加载一次汇率信息，服务端就需要将前5分钟的信息展示给用户，其实是可以实现的，这里只是一个小demo，就暂且写成这样。</p>
<hr>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>第一步，后端需要获取到实时汇率信息，</p>
<p>可以利用requests定时请求固定资源，这里我是从新浪财经获取到的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange_rate</span>():</span></span><br><span class="line">    url = <span class="string">&#x27;https://hq.sinajs.cn/rn=1606355458081list=fx_susdcny&#x27;</span></span><br><span class="line">    res = requests.get(url=url)</span><br><span class="line">    date = re.search(<span class="string">r&#x27;\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;&#x27;</span>, res.text).group()</span><br><span class="line">    exchange_rate = re.search(<span class="string">r&#x27;\d.\d&#123;4&#125;&#x27;</span>, res.text).group()</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;date&#x27;</span>: date,</span><br><span class="line">        <span class="string">&#x27;exchange_rate&#x27;</span>: exchange_rate</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据形式：&#123;&#x27;date&#x27;: &#x27;22:10:00&#x27;, &#x27;exchange_rate&#x27;: &#x27;6.5768&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里写了一个简单的爬虫，由于网站的不同，需要根据个人情况而定，返回的数据大概就是这样的。一个最新的时间以及汇率。</p>
<h4 id="2-前后端连接websocket"><a href="#2-前后端连接websocket" class="headerlink" title="2. 前后端连接websocket"></a>2. 前后端连接websocket</h4><p>这里还是值得推敲的，我们为什么要使用<strong>websocket</strong>而不用传统的<strong>http</strong>协议呢。</p>
<p>就我们这个demo来说，使用http，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。这种<strong>单向请求</strong>的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<strong>“轮询”</strong>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。可想而知效率是有多低，这个太low了，我们要用就用高大上的。WebSocket 协议它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<strong>服务器推送技术</strong>的一种。</p>
<p><strong>vue端发起链接请求，页面挂载时调用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">link_ws</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断浏览器是否支持websocket</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params"><span class="string">&quot;WebSocket&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;支持&quot;</span>)</span><br><span class="line">            <span class="comment">// 生成websocket链接</span></span><br><span class="line">            <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://192.168.1.119:8000/websocket_link/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送链接请求</span></span><br><span class="line">            ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// 这里的参数是可以随意改变的，也可以将用户凭证传给后端作为存储对象</span></span><br><span class="line">                ws.send(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取服务端返回数据</span></span><br><span class="line">            ws.onmessage = <span class="function">(<span class="params">evt</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(evt.data)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 捕获断开链接</span></span><br><span class="line">            ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;链接已经关闭&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.link_ws();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实都是websocket使用的一些基本方法，也是简单明了的</p>
<p><strong>django端接收链接请求并定时主动推送汇率信息</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入dwebsocket的库</span></span><br><span class="line"><span class="keyword">from</span> dwebsocket.decorators <span class="keyword">import</span> accept_websocket</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最新汇率</span></span><br><span class="line"><span class="keyword">from</span> utils.mk_exchange_rate <span class="keyword">import</span> exchange_rate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端列表</span></span><br><span class="line">clients = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">websocket_link</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket():</span><br><span class="line"></span><br><span class="line">        uid = <span class="built_in">str</span>(uuid1())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">			</span><br><span class="line">            <span class="comment"># 接收前端</span></span><br><span class="line">            message = request.websocket.wait()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> message:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">&#x27;websocket链接成功&#x27;</span>)</span><br><span class="line">                <span class="comment"># 存储客户端对象</span></span><br><span class="line">                clients[uid] = request.websocket</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 只要保持连接状态，就循环不停的推送</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">if</span> clients:</span><br><span class="line">                        <span class="comment"># 获取最新汇率信息</span></span><br><span class="line">                        res = exchange_rate()</span><br><span class="line">                        data = &#123;<span class="string">&#x27;date&#x27;</span>: res.get(<span class="string">&#x27;date&#x27;</span>), <span class="string">&#x27;exchange_rate&#x27;</span>: res.get(<span class="string">&#x27;exchange_rate&#x27;</span>)&#125;</span><br><span class="line">                        <span class="comment"># 以json格式返回给前端</span></span><br><span class="line">                        clients[uid].send(json.dumps(data))</span><br><span class="line">                        <span class="comment"># 定时60秒循环推送一次</span></span><br><span class="line">                        time.sleep(<span class="number">60</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>配置好路由，一切工作做完之后。就只差前端接收数据进行渲染了。需要注意的是，vue端进行渲染的时候数据是分为两个数组。其实从上面的方法中可以看出，需要渲染的数据大概就是这样的</p>
<p><img src="https://img-blog.csdnimg.cn/20201126234729433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>由此可以看出，我们需要的数据在最终渲染时也是要转换为两个数组，不难看出，带入到我们的demo中，xAxis是时间点，series中是汇率的信息，是不是就好办多了。</p>
<p>在websocket中的<strong>ws.onmessage</strong>方法获取服务端返回数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取服务端返回数据</span></span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">evt</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 将获取信息打印</span></span><br><span class="line">    <span class="comment">// console.log(evt.data)</span></span><br><span class="line">    <span class="comment">// console.log(typeof(JSON.parse(evt.data)))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(evt.data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将返回信息添加到数组末尾</span></span><br><span class="line">    <span class="built_in">this</span>.date.push(data[<span class="string">&#x27;date&#x27;</span>])</span><br><span class="line">    <span class="built_in">this</span>.exchange_rate.push(data[<span class="string">&#x27;exchange_rate&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用队列的思想</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.date.length &gt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="comment">// 删除队列头部元素</span></span><br><span class="line">        <span class="built_in">this</span>.date.shift()</span><br><span class="line">        <span class="built_in">this</span>.exchange_rate.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.drawChart()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于后端返回的是一个json对象，我们需要把它先解析成为一个对象再从中获取元素，把这两个数组分别当成队列。利用队列的思想，如果数组长度达到上限，我们就在末尾添加的同时删除头部元素，就很好的解决这个问题了。数据接收没问题之后，每次数据更新都进行重新渲染，大功告成！</p>
<p>结语：在基于ECharts以及websocket协议完成了实时推送汇率动态渲染的功能，不得不说，麻雀虽小五脏俱全，这都是日常学习积累的成果，技术广的同时，将所学知识灵活运用，感觉还是特别棒的！</p>
]]></content>
  </entry>
  <entry>
    <title>停止、删除所有的docker容器和镜像，以及windows下删除问题解决</title>
    <url>/2020/12/08/%E5%81%9C%E6%AD%A2%E3%80%81%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E7%9A%84docker%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%EF%BC%8C%E4%BB%A5%E5%8F%8Awindows%E4%B8%8B%E5%88%A0%E9%99%A4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h3 id="停止、删除所有的docker容器和镜像，以及windows下删除问题解决"><a href="#停止、删除所有的docker容器和镜像，以及windows下删除问题解决" class="headerlink" title="停止、删除所有的docker容器和镜像，以及windows下删除问题解决"></a>停止、删除所有的docker容器和镜像，以及windows下删除问题解决</h3><p>这些命令总是记不住，或者说不用心去记，所以记录在本文中，以便将来查询。</p>
<a id="more"></a>

<h4 id="列出所有的容器ID"><a href="#列出所有的容器ID" class="headerlink" title="列出所有的容器ID"></a>列出所有的容器ID</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>

<h4 id="停止所有的容器"><a href="#停止所有的容器" class="headerlink" title="停止所有的容器"></a>停止所有的容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<h4 id="删除所有的容器"><a href="#删除所有的容器" class="headerlink" title="删除所有的容器"></a>删除所有的容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<h4 id="删除所有的镜像"><a href="#删除所有的镜像" class="headerlink" title="删除所有的镜像"></a>删除所有的镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>

<h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp mycontainer:&#x2F;opt&#x2F;file.txt &#x2F;opt&#x2F;local&#x2F;</span><br><span class="line">docker cp &#x2F;opt&#x2F;local&#x2F;file.txt mycontainer:&#x2F;opt&#x2F;</span><br></pre></td></tr></table></figure>

<p>如果是win10系统下使用Docker Desktop执行停止或者删除命令，有可能会遇到如下问题</p>
<p> <img src="https://img-blog.csdnimg.cn/20201208081933969.png#pic_center"></p>
<p>如果在 CMD 命令提示符下删除容器可能失败，可切换至 PowerShell 中执行成功。</p>
<p>PowerShell，从名字可以知道，他首先是一个shell，shell的意思就是和Linux的bash等一样、和原来的cmd一样就是在里边敲命令（可执行文件）使用</p>
<p><img src="https://img-blog.csdnimg.cn/2020120808201355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>直接在win10搜索框中输入PowerShell就可以</p>
<p> <img src="https://img-blog.csdnimg.cn/20201208082036594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>切换至PowerShell删除成功！</p>
]]></content>
  </entry>
  <entry>
    <title>工作流的流转</title>
    <url>/2019/03/08/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84%E6%B5%81%E8%BD%AC/</url>
    <content><![CDATA[<h3 id="工作流的流转"><a href="#工作流的流转" class="headerlink" title="工作流的流转"></a>工作流的流转</h3><h4 id="1-worktype表"><a href="#1-worktype表" class="headerlink" title="1. worktype表"></a>1. worktype表</h4><p>工作类型，作用是根据工单类型来创建工单，其中有两个特殊的字段在这里做一下解释</p>
<a id="more"></a>

<ul>
<li>fields：自定义字段，顾名思义就是需要用户（一般只有管理员有权限）在创建类型时自己定义的字段，举个例子：比如请假类型，它会有自己独立的属性，开始时间，结束时间，天数等，而换一种类型，比如购物，又会有购物独特的属性，所以我们需要把这些类型的属性作为一个字段，它存储在数据库中的格式是json</li>
<li>auditor：审批人，在创建类型时需要指定有哪些人来审批，它的审批人可能是一个，也有可能是多个，我们不能知道它具体的数量，所以也需要用json的类型来存储，存储格式：”[1, 4, 2]”，需要注意的就是：这个list中是用户id，审批过程中是有序的</li>
</ul>
<p>表结构：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>primary key</td>
<td>主键自增</td>
</tr>
<tr>
<td>type_name</td>
<td>varchar</td>
<td>类型名称</td>
</tr>
<tr>
<td>fields</td>
<td>text</td>
<td>自定义字段(json)</td>
</tr>
<tr>
<td>auditor</td>
<td>varchar</td>
<td>审批人列表</td>
</tr>
</tbody></table>
<h4 id="2-work表"><a href="#2-work表" class="headerlink" title="2.work表"></a>2.work表</h4><p>工单表，即通用的工作流程表，代表一项目完整事务，status表示状态，有进行中，完结，终止三种状态，type指向具体工单类型，例如贷款事务，取款事务。</p>
<p>uid指向具体申请人，作为user表逻辑外键</p>
<p>next_id指向下一个任务，工单在创建成功的同时，会在task表中生成相应的任务，任务数取决于该工单对应的类型中的审批人list，根据审批人列表来有序创建task，初次创建工单时，next指向下一个任务</p>
<p>表结构：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>primary key</td>
<td>主键自增</td>
</tr>
<tr>
<td>uid</td>
<td>int</td>
<td>申请人</td>
</tr>
<tr>
<td>work_data</td>
<td>text</td>
<td>自定义数据(json)</td>
</tr>
<tr>
<td>type_id</td>
<td>int</td>
<td>工单类型</td>
</tr>
<tr>
<td>next_id</td>
<td>int</td>
<td>下一个任务</td>
</tr>
</tbody></table>
<h4 id="3-task表"><a href="#3-task表" class="headerlink" title="3. task表"></a>3. task表</h4><p>任务表，即操作任务表，表代表一种操作类型，work_id指向具体工单，aid指向具体的审批人id，status代表审核状态，有通过，拒绝，终止三种状态，分别用0，1，2来代替。审批人在审批过程中，如果同意，就把状态改为1，并且work表中next_id指向下一个任务，如果在审批过程中拒绝了，状态直接修改为2，并且把next_id赋值为0，后续的任务就不会触发了。</p>
<p>表结构：</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>primary key</td>
<td>主键自增</td>
</tr>
<tr>
<td>work_id</td>
<td>int</td>
<td>具体工单</td>
</tr>
<tr>
<td>work_data</td>
<td>text</td>
<td>审批人id</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>审核状态</td>
</tr>
<tr>
<td>content</td>
<td>varchar</td>
<td>审批意见</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>权限系统</title>
    <url>/2020/05/02/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="权限系统"><a href="#权限系统" class="headerlink" title="权限系统"></a>权限系统</h2><h3 id="1-什么是权限"><a href="#1-什么是权限" class="headerlink" title="1. 什么是权限"></a>1. 什么是权限</h3><p>说到权限管理，首先要了解，在网站中权限到底是什么？</p>
<p>在网站中，用户通过URL地址，进入网站的后端逻辑，从而对网站的数据库进行操作管理。如果想要让拥有操作管理权限的用户来完成，而没有权限的用户无法操作.</p>
<a id="more"></a>

<h3 id="2-ACL权限模型"><a href="#2-ACL权限模型" class="headerlink" title="2. ACL权限模型"></a>2. ACL权限模型</h3><p>规定<strong>资源</strong>可以被哪些<strong>主体</strong>进行哪些<strong>操作</strong></p>
<p>场景：管理系统</p>
<p>适用资源：用户管理页面、工单管理页面</p>
<p>在ACL权限模型下，权限管理是围绕<strong>资源</strong>来设定的。我们可以对不同资源页面设定可以访问的用户。配置形式如下</p>
<p><img src="https://img-blog.csdnimg.cn/20201203150926733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>在用户量大的情况下，比如将不同的用户视为不同的资源，在动态情况下，权限经常变动，每添加一名员工，都需要配置所有他访问的资源，在频繁变动的大型系统里，是很难维护的。</p>
<h3 id="3-RBAC基于角色的访问控制"><a href="#3-RBAC基于角色的访问控制" class="headerlink" title="3. RBAC基于角色的访问控制"></a>3. RBAC基于角色的访问控制</h3><ul>
<li>规定<strong>角色</strong>可以对哪些<strong>资源</strong>进行哪些<strong>操作</strong></li>
<li>规定<strong>主体</strong>拥有哪些<strong>角色</strong></li>
</ul>
<p>还是上面那个场景，比如，将多个用户分配到一个角色下，相当于分组，然后设置哪个角色组拥有哪些节点权限，这种方式，避免了ACL模型下，每次新人入职，需要配置资源表的情况。同样，权限变动也变的很方便，只要修改角色，即可实现用户的权限修改。</p>
<p><img src="https://img-blog.csdnimg.cn/20201203151001683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>用户和组两个概念可能会让人混淆，区分一下：</p>
<ul>
<li>角色赋予的是主体，主体可以是用户，也可以是组</li>
<li>组是用户的集合</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>排行榜</title>
    <url>/2019/02/16/%E6%8E%92%E8%A1%8C%E6%A6%9C/</url>
    <content><![CDATA[<p>排行榜的底层逻辑就是：有序集合</p>
<p>集合（set）去重底层逻辑就是：比如捞鱼，一个池子里有好多鱼，我就想把鱼捞出来，过程中我不想要重样的鱼，在准备一个缸，一条一条捞，每一次捞的时候都给那个缸里面的鱼进行作对比，一旦发现有重样的就扔掉，结果这个缸里的鱼都是不重样的。</p>
<h3 id="数据量大的排行榜用-redis有序集合"><a href="#数据量大的排行榜用-redis有序集合" class="headerlink" title="数据量大的排行榜用 redis有序集合"></a>数据量大的排行榜用 redis有序集合</h3><p><strong>链表（无序）：搜索性能非常差，修改速度特别快</strong><br><strong>数组（有序）：搜索性能特别快，修改速度特别慢  （例子：电影院坐错位置）</strong></p>
<p>解决链表搜索性能慢问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">利用跳表，也可以多重跳表</span><br><span class="line">跳表：运用位于运算分为奇偶数两张表，这样就节约了一半的成本</span><br></pre></td></tr></table></figure>

<p>二进制判断奇偶数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 &amp; 1 &#x3D; 0    #偶数</span><br><span class="line">3 &amp; 1 &#x3D; 1 	  #奇数</span><br></pre></td></tr></table></figure>



<p>不多说，上代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myrange 4 uid1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myrange 1 uid4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange myrange 0 10</span><br><span class="line">1) &quot;uid4&quot;</span><br><span class="line">2) &quot;uid1&quot;</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>总结</title>
    <url>/2021/03/29/%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="用户的三种校验方式"><a href="#用户的三种校验方式" class="headerlink" title="用户的三种校验方式"></a>用户的三种校验方式</h2><ul>
<li><p>用户名和密码</p>
<blockquote>
<ul>
<li>what you know</li>
</ul>
</blockquote>
</li>
<li><p>用户名和密钥</p>
<blockquote>
<ul>
<li>what you have</li>
</ul>
</blockquote>
</li>
<li><p>用户名和实体</p>
<blockquote>
<ul>
<li>who you are</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h2 id="docker的基本操作"><a href="#docker的基本操作" class="headerlink" title="docker的基本操作"></a>docker的基本操作</h2><blockquote>
<p>docker是一种容器技术,有三大核心:  <strong>镜像   容器    仓库</strong></p>
</blockquote>
<ul>
<li>查看本地所有镜像<ul>
<li>docker images</li>
</ul>
</li>
<li>拉取镜像<ul>
<li>docker pull 镜像名称</li>
</ul>
</li>
<li>删除镜像<ul>
<li>docker rmi 镜像id</li>
</ul>
</li>
<li>镜像的导出<ul>
<li>docker save -o ‘c:/tmp/redis.tar’ redis</li>
</ul>
</li>
<li>镜像的导入<ul>
<li>docker load -i ‘c:/tmp/redis.tar’</li>
</ul>
</li>
<li>当前有哪些容器正在启动<ul>
<li>docker ps</li>
</ul>
</li>
<li>停止docker服务<ul>
<li>docker stop 容器id</li>
</ul>
</li>
</ul>
<hr>
<h2 id="python实现设计模式——工厂模式"><a href="#python实现设计模式——工厂模式" class="headerlink" title="python实现设计模式——工厂模式"></a>python实现设计模式——工厂模式</h2><p>工厂模式，顾名思义就是我们可以通过指定的”工厂“获取需要的”产品“，在设计模式中主要用于抽象对象的创建过程，让用户可以指定自己想要的对象而不必关心对象的实例化过程。这样做的好处就是用户只需要通过固定的接口而不是直接去调用类的实例化方法来获取一个对象的实例，隐藏了实例创建过程的复杂度，解耦了生产实例和使用实例的代码，降低了维护的复杂度</p>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mercedes</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    梅赛德斯</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mercedes-Benz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    宝马</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BMW&quot;</span></span><br></pre></td></tr></table></figure>

<p>假设我们有两个品牌汽车分别Mercedes和BMW，如果没有”工厂“来生产他们，我们就要在代码中自己进行实例化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mercedes = Mercedes()</span><br><span class="line">bmw = BMW()</span><br></pre></td></tr></table></figure>

<p>但现实中，你可能会面临很多汽车产品，而且每个产品的构造参数也不相同，这样在创建实例的会麻烦，这时就可以构造一个”简单工厂“把所有汽车实例化过程封装在里面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    简单工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;mb&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> Mercedes()</span><br><span class="line">        <span class="keyword">elif</span> name == <span class="string">&quot;bmw&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> BMW()</span><br></pre></td></tr></table></figure>

<p>有了SimpleCarFactory类后，就可以通过固定的接口传入参数获得想要的对象实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c1 = SimpleCarFactory.product_car(<span class="string">&quot;mb&quot;</span>)</span><br><span class="line">c2 = SimpleCarFactory.product_car(<span class="string">&quot;bmw&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>虽然有了一个简单的工厂，但在实际使用工厂的过程中，我们会发现新问题：如果我们要新增一个”产品“，例如Audi的汽车，我们除了新增一个Audi类外还要修改SimpleCarFactory内的product_car方法。这样就违背了软件设计中的开闭原则，即在拓展新的类时，尽量不要修改原有的代码。所以我们在简单工厂的基础上把SimpleCarFactory抽象成不同的工厂，每个工厂对应生成自己的产品，这就是工厂方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstactmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MercedesFactory</span>(<span class="params">AbstractFactory</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    梅赛德斯工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Mercedes()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span>(<span class="params">AbstractFactory</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    宝马工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> BMW()</span><br></pre></td></tr></table></figure>

<p>我们把工厂抽象出来用abc模块实现一个抽象基类AbsstractFactory,这样就可以通过特定的工厂来获得特定的产品实例了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c1 = MercedesFactory.product_car()</span><br><span class="line">c2 = BMWFactory.product_car()</span><br></pre></td></tr></table></figure>

<p>每个工厂负责生成自己的产品也避免了我们在新增产品时需要修改工厂的代码，而只要增加对应的工厂即可。如新增一个Audi产品，只需新增一个Audi类和AudiFactory类</p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>工厂方法虽然解决了我们”修改代码“的问题，但如果我们要生产很多产品，就会发现我们同样需要写很多对应的工厂类。比如梅赛德斯和宝马不仅生产小汽车，还要生产suv，那我们用工厂方法就要再多构造两个生产suv的工厂类。所以为了解决这个问题，我们就要再更近一步的抽象工厂类，让一个工厂可以生产同一类的多个产品，这就是抽象工厂。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种小汽车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mercedes_C63</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    梅赛德斯小汽车</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mercedes-Benz:c63&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW_M3</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    宝马小汽车</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BMW:M3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种suv    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mercedes_G63</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    梅赛德斯suv</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mercedes-Benz:G63&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW_X5</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    宝马suv</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BMW:x5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象工厂</span></span><br><span class="line"><span class="string">    可以生产小汽车，还可以生产suv</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_suv</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MercedesFactory</span>(<span class="params">AbstractFactory</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    梅赛德斯工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Mercedes_C63()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_suv</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Mercedes_G63()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span>(<span class="params">AbstractFactory</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    宝马工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> BMW_M3()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_suv</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> BMW_X5()    </span><br></pre></td></tr></table></figure>

<p>我们让基类AbstractFactory同时可以生产汽车和SUV，然后MercedesFactory和BMWFactory继承AbstractFactory并重写product_car和product_suv方法即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c1 = MercedesFactory().product_car()</span><br><span class="line">s1 = MercedesFactory().product_suv()</span><br><span class="line"></span><br><span class="line">c2 = BMWFactory().product_car()</span><br><span class="line">s2 = BMWFactory.product_car()</span><br></pre></td></tr></table></figure>

<p>抽象工厂模式与工厂方法模式最大区别在于，抽象工厂中的一个工厂对象可以负责多个不同产品对象的创建，这样比工厂方法模式更为简单，有效率</p>
<hr>
<h2 id="权限模型"><a href="#权限模型" class="headerlink" title="权限模型"></a>权限模型</h2><h4 id="首先第一种也是相对较早的权限模型ACL"><a href="#首先第一种也是相对较早的权限模型ACL" class="headerlink" title="首先第一种也是相对较早的权限模型ACL"></a>首先第一种也是相对较早的权限模型ACL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access ControI List</span><br></pre></td></tr></table></figure>

<p>ACL是最先也是最基本的一种访问控制机制，它的原理很是简单：每一项资源，都配有一个列表，这个列表记录的就是那些用户对这项资源执行增删改查的那些操作，当系统系统试图访问这项资源时，会首先检查这个列表中是否有关于当前用户的访问权限，从而确认当前的用户是否能执行相应的操作</p>
<p>ACL是一种面向资源的访问控制模型，它的机制是围绕“资源”展开的</p>
<p>在表结构中，定义用户、权限、节点(也就是可以进行CRUD的资源)三张表</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">user表</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">uid</td>
<td align="left">int</td>
<td align="left">主键</td>
</tr>
<tr>
<td align="left">username</td>
<td align="left">varchar()</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">password</td>
<td align="left">varchar()</td>
<td align="left"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">access表</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">user_id</td>
<td align="left">int</td>
<td align="left">外键关联用户表</td>
</tr>
<tr>
<td align="left">node_id</td>
<td align="left">int</td>
<td align="left">外键关联节点表</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">node表</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">int</td>
<td align="left">主键</td>
</tr>
<tr>
<td align="left">node_name</td>
<td align="left">varchar()</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>验证权限时，通过确认那个用户访问要那个资源，根据他的外键关联来使用sql语句查询是否有这个权限</p>
<p>但是，如果用户量特别大的情况，需要要维护大量的权限表，ACL在性能上有明显的缺陷，另外，对于拥有大量用户与众多资源的应用，管理访问控制列表自己就非常繁重</p>
<h4 id="基于角色的RBAC"><a href="#基于角色的RBAC" class="headerlink" title="基于角色的RBAC"></a>基于角色的RBAC</h4><p>RBAC 是把用户按照角色进行归并，通过用户角色来肯定用户可否针对某项资源进行某项操作。</p>
<p>RBAC相对于ACL最大的优点就是简化了用户和权限的管理，经过对用户进行分类，使得角色与权限关联起来，使得角色和权限变成了间接关联</p>
<p>RBAC认为权限实际就是who,what,how三者之间的关系，即who对what进行how的操作。</p>
<ul>
<li>Who:权限的拥有者或主体</li>
<li>what:权限针对的的对象或者资源</li>
<li>how:是对资源具体的怎么操作</li>
</ul>
<p>RBAC是面向资源的，他对用户的授权管理变得很是简单易于维护，所以有普遍的应用</p>
<p>但是RBAC也是有自己的缺点的，因为他是以角色为载体的，如果角色下的个别用户需要分配一些特殊的权限定制，那么RBAC就无能为力，所以就要使用到ABAC，在下章文章中详解</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">user表</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">uid</td>
<td align="left">int</td>
<td align="left">主键</td>
</tr>
<tr>
<td align="left">username</td>
<td align="left">varchar()</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">password</td>
<td align="left">varchar()</td>
<td align="left"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">role表</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">int</td>
<td align="left">主键</td>
</tr>
<tr>
<td align="left">role_name</td>
<td align="left">varchar()</td>
<td align="left"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">access表</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">role_id</td>
<td align="left">int</td>
<td align="left">外键关联角色表</td>
</tr>
<tr>
<td align="left">node_id</td>
<td align="left">int</td>
<td align="left">外键关联节点表</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">node表</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">int</td>
<td align="left">主键</td>
</tr>
<tr>
<td align="left">node_name</td>
<td align="left">varchar()</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="来吧，使用django代码实现一下RBAC"><a href="#来吧，使用django代码实现一下RBAC" class="headerlink" title="来吧，使用django代码实现一下RBAC"></a>来吧，使用django代码实现一下RBAC</h4><h6 id="首先在model-py中建好对应表"><a href="#首先在model-py中建好对应表" class="headerlink" title="首先在model.py中建好对应表"></a>首先在<code>model.py</code>中建好对应表</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入时间域</span></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params">models.Model</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建时间</span></span><br><span class="line">    create_time = models.DateTimeField(default=timezone.now,null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 角色表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Relo</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;relo&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    phone = models.CharField(max_length=<span class="number">11</span>)</span><br><span class="line">    email = models.CharField(max_length=<span class="number">24</span>)</span><br><span class="line">    nickname = models.CharField(max_length=<span class="number">24</span>)</span><br><span class="line">    role = models.ForeignKey(Relo, on_delete=models.SET_NULL, null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    node_name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;node&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 权限表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Access</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    role = models.ForeignKey(Relo, on_delete=models.SET_NULL, null=<span class="literal">True</span>)</span><br><span class="line">    node = models.ForeignKey(Node, on_delete=models.SET_NULL, null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&quot;access&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="新建一个check-authority-py文件-定义用户权限类，定义一个查询用户管理方法，有权限返回True否则返回False"><a href="#新建一个check-authority-py文件-定义用户权限类，定义一个查询用户管理方法，有权限返回True否则返回False" class="headerlink" title="新建一个check_authority.py文件,定义用户权限类，定义一个查询用户管理方法，有权限返回True否则返回False"></a>新建一个check_authority.py文件,定义用户权限类，定义一个查询用户管理方法，有权限返回True否则返回False</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> .utils <span class="keyword">import</span> chack_jwt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询用户权限</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAuthority</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, token</span>):</span></span><br><span class="line">        self.db = pymysql.connect(host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">3306</span>, database=<span class="string">&#x27;workflow&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&quot;mysql&quot;</span>, charset=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">        self.cursor = self.db.cursor()</span><br><span class="line">        self.token = token</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询用户管理权限</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">manage_authority</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.token:</span><br><span class="line">            token = self.token[<span class="number">4</span>:]</span><br><span class="line">            uid = chack_jwt(token).get(<span class="string">&quot;uid&quot;</span>)</span><br><span class="line"></span><br><span class="line">            self.cursor.execute(<span class="string">&quot;select a.username,b.name,c.node_id,d.node_name from user a left join role b on a.role_id=b.id left join access c on b.id=c.role_id left join node d on c.node_id=d.id &quot;</span></span><br><span class="line">                                <span class="string">&quot;where a.id=&quot;</span></span><br><span class="line">                                +<span class="built_in">str</span>(uid))</span><br><span class="line">            <span class="comment"># 获取查询结果</span></span><br><span class="line">            desc = self.cursor.description</span><br><span class="line">            result = [<span class="built_in">dict</span>(<span class="built_in">zip</span>([col[<span class="number">0</span>] <span class="keyword">for</span> col <span class="keyword">in</span> desc], row)) <span class="keyword">for</span> row <span class="keyword">in</span> self.cursor.fetchall()]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果权限包括用户管理那就可以放行</span></span><br><span class="line">            <span class="keyword">for</span> ui <span class="keyword">in</span> result:</span><br><span class="line">                <span class="keyword">if</span> ui.get(<span class="string">&quot;node_name&quot;</span>) == <span class="string">&quot;用户管理&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h6 id="然后在中间件中进行调用"><a href="#然后在中间件中进行调用" class="headerlink" title="然后在中间件中进行调用"></a>然后在中间件中进行调用</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMiddleware</span>(<span class="params">MiddlewareMixin</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        url = request.META.get(<span class="string">&quot;PATH_INFO&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> url == <span class="string">&quot;/myapp/userview/&quot;</span>:</span><br><span class="line">            token = request.META.get(<span class="string">&quot;HTTP_AUTHORIZATION&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 调用定义好的类方法，True就不做任何操作，直接放行，否则直接返回没有权限</span></span><br><span class="line">            authority = UserAuthority(token=token).manage_authority()</span><br><span class="line">            <span class="keyword">if</span> authority:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">&quot;code&quot;</span>: <span class="string">&quot;999&quot;</span>, <span class="string">&quot;data&quot;</span>: <span class="string">&quot;您没有权限&quot;</span>&#125;, ensure_ascii=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span>(<span class="params">self, request, view_func, view_args, view_kwargs</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span>(<span class="params">self, request, exception</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">self, request, response</span>):</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<h6 id="然后在settings的MIDDLEWARE中进行注册就可以了，就是这么简单"><a href="#然后在settings的MIDDLEWARE中进行注册就可以了，就是这么简单" class="headerlink" title="然后在settings的MIDDLEWARE中进行注册就可以了，就是这么简单"></a>然后在settings的MIDDLEWARE中进行注册就可以了，就是这么简单</h6>]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>注册功能+邮件验证</title>
    <url>/2018/09/01/%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD-%E9%82%AE%E4%BB%B6%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h2 id="django实现注册模块"><a href="#django实现注册模块" class="headerlink" title="django实现注册模块"></a>django实现注册模块</h2><p>这篇文章主要介绍了Python Django 实现简单注册功能过程详解,文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值,需要的朋友可以参考下</p>
<a id="more"></a>

<h3 id="1-用户模型设计：models-py"><a href="#1-用户模型设计：models-py" class="headerlink" title="1. 用户模型设计：models.py"></a>1. 用户模型设计：<code>models.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    <span class="comment"># 创建时间</span></span><br><span class="line">    create_time = models.DateTimeField(default=timezone.now, null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    phone = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    email = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;user&#x27;</span></span><br></pre></td></tr></table></figure>

<p>需要注意：注册过程中需要判断用户名是否存在，但是做大型项目的话，读取数据库是非常不现实的，我们需要给username加一个unique索引，在完成校验后直接入库，如果有异常的话，就是username已存在，可以利用异常捕获来处理，减轻数据库压力。</p>
<h3 id="2-注册页面"><a href="#2-注册页面" class="headerlink" title="2. 注册页面"></a>2. 注册页面</h3> <img src=".\images\注册页面.png" style="zoom:67%;" />

<p>需要注意：在用户填写好表单信息之后，需要利用邮箱验证，首先要点击按钮，触发发邮件接口，详见下文</p>
<h3 id="3-辅助工具"><a href="#3-辅助工具" class="headerlink" title="3. 辅助工具"></a>3. 辅助工具</h3><ul>
<li><p>redis缓存</p>
</li>
<li><p>send_email脚本</p>
</li>
<li><p>md5加密：</p>
<p>md5加密后是不可逆的，用到的是hashlib库</p>
<p>注册时需要将password制作成md5密文，并且登录进行比对时也需要先将用户输入的pwd加密</p>
</li>
</ul>
<h4 id="3-1-utils-send-email-py-发送邮件验证码"><a href="#3-1-utils-send-email-py-发送邮件验证码" class="headerlink" title="3.1 utils/send_email.py  发送邮件验证码"></a>3.1 <code>utils/send_email.py</code>  发送邮件验证码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送方</span></span><br><span class="line">my_mail = <span class="string">&quot;xxxxxxxx@qq.com&quot;</span></span><br><span class="line"><span class="comment"># 授权码(qq邮箱的授权码)</span></span><br><span class="line">my_pass = <span class="string">&quot;tgwczatezutohhej&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义发送邮件的方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail</span>(<span class="params">subject, content, mailaddr</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param subject: 标题</span></span><br><span class="line"><span class="string">    :param content: 发送内容</span></span><br><span class="line"><span class="string">    :param mailaddr: 接收方邮箱</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 声明邮件对象</span></span><br><span class="line">    msg = MIMEText(content, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置发送发对象</span></span><br><span class="line">    msg[<span class="string">&#x27;From&#x27;</span>] = formataddr([<span class="string">&#x27;在线教育平台&#x27;</span>, my_mail])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置收件方对象</span></span><br><span class="line">    msg[<span class="string">&#x27;To&#x27;</span>] = formataddr([<span class="string">&#x27;尊敬的客户&#x27;</span>, mailaddr])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置标题</span></span><br><span class="line">    msg[<span class="string">&#x27;Subject&#x27;</span>] = subject</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置smtp服务器</span></span><br><span class="line">    server = smtplib.SMTP_SSL(<span class="string">&quot;smtp.qq.com&quot;</span>, <span class="number">465</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登录邮箱</span></span><br><span class="line">    server.login(my_mail, my_pass)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送邮件</span></span><br><span class="line">    server.sendmail(my_mail, [mailaddr], msg.as_string())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭smtp链接</span></span><br><span class="line">    server.quit()</span><br><span class="line"></span><br><span class="line">mail(<span class="string">&#x27;验证码验证服务&#x27;</span>, <span class="string">&#x27;6666&#x27;</span>, <span class="string">&#x27;xxxxxx@qq.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-utils-redis-cache-py-利用redis缓存并设置验证码有效期"><a href="#3-2-utils-redis-cache-py-利用redis缓存并设置验证码有效期" class="headerlink" title="3.2 utils/redis_cache.py   利用redis缓存并设置验证码有效期"></a>3.2 <code>utils/redis_cache.py </code>  利用redis缓存并设置验证码有效期</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接</span></span><br><span class="line">r = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将邮箱验证码存入redis，设置有效期</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">email_cache</span>(<span class="params">email, code</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置值</span></span><br><span class="line">    r.<span class="built_in">set</span>(email, code)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置有效期</span></span><br><span class="line">    r.expire(email, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.ttl(email)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将用户输入的验证码与redis中的缓存比对</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">email_code</span>(<span class="params">email, code</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = r.get(email)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">str</span>(res, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res == code:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-views-py-发送邮件验证码接口"><a href="#3-3-views-py-发送邮件验证码接口" class="headerlink" title="3.3 views.py  发送邮件验证码接口"></a>3.3 <code>views.py</code>  发送邮件验证码接口</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.send_email <span class="keyword">import</span> mail</span><br><span class="line"><span class="keyword">from</span> utils.redis_cache <span class="keyword">import</span> email_cache, email_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendEmail</span>(<span class="params">APIView</span>):</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 接收参数</span></span><br><span class="line">		username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">		email = request.POST.get(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 校验邮箱合法性</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">r&#x27;[0-9a-zA-Z_]&#123;0,19&#125;@(.*?).com$&#x27;</span>, email):</span><br><span class="line">			<span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;邮箱不合法&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 判断是否发送频繁</span></span><br><span class="line">		<span class="keyword">if</span> r.get(email):</span><br><span class="line">			<span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;发送频繁&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">400</span>&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 生成随机验证码</span></span><br><span class="line">		code = <span class="built_in">str</span>(random.randint(<span class="number">1000</span>, <span class="number">9999</span>))</span><br><span class="line"></span><br><span class="line">		content = <span class="string">&quot;尊敬的&quot;</span> + username + <span class="string">&quot;,您的验证码为：&quot;</span> + code + <span class="string">&quot;,有效期为5分钟&quot;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 将生成的随机验证码存入redis，email为key，code为value</span></span><br><span class="line">		email_cache(email, code)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 发送邮件给用户</span></span><br><span class="line">		mail(<span class="string">&#x27;验证码验证服务&#x27;</span>, content, email)</span><br><span class="line">		<span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;邮箱发送成功&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-4-md5进行密码加密"><a href="#3-4-md5进行密码加密" class="headerlink" title="3.4 md5进行密码加密"></a>3.4 md5进行密码加密</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_password</span>(<span class="params">mypass</span>):</span></span><br><span class="line"></span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义加密对象</span></span><br><span class="line">    sign_str = mypass</span><br><span class="line">    <span class="comment"># 转码</span></span><br><span class="line">    sign_utf8 = <span class="built_in">str</span>(sign_str).encode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 加密</span></span><br><span class="line">    md5.update(sign_utf8)</span><br><span class="line">    <span class="comment"># 生成密文</span></span><br><span class="line">    md5_server = md5.hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> md5_server</span><br></pre></td></tr></table></figure>

<h3 id="4-注册接口"><a href="#4-注册接口" class="headerlink" title="4. 注册接口"></a>4. 注册接口</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span>(<span class="params">APIView</span>):</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 接收参数</span></span><br><span class="line">		username = request.POST.get(<span class="string">&quot;username&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">		password = request.POST.get(<span class="string">&quot;password&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">		email = request.POST.get(<span class="string">&quot;email&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">		phone = request.POST.get(<span class="string">&quot;phone&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">		code = request.POST.get(<span class="string">&quot;code&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># md5进行密码加密</span></span><br><span class="line">		str_md5 = make_password(password)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 校验数据</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>([username, password, email, phone, code]):</span><br><span class="line">			<span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;数据不完整&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">r&quot;^1[356789]\d&#123;9&#125;$&quot;</span>, phone):</span><br><span class="line">			<span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;手机号不合法&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 用自定义方法，对比邮箱验证码</span></span><br><span class="line">		<span class="keyword">if</span> email_code(email, code):</span><br><span class="line">			<span class="comment"># 唯一性验证</span></span><br><span class="line">			<span class="keyword">try</span>:</span><br><span class="line">				user = User(username=username, password=str_md5, phone=phone, email=email)</span><br><span class="line">				user.save()</span><br><span class="line">				<span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;注册成功&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">			<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">				print(e)</span><br><span class="line">				<span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;注册失败&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">400</span>&#125;)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> Response(&#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;验证码错误&#x27;</span>, <span class="string">&#x27;code&#x27;</span>: <span class="number">400</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>物理外键和逻辑外键</title>
    <url>/2019/10/08/%E7%89%A9%E7%90%86%E5%A4%96%E9%94%AE%E5%92%8C%E9%80%BB%E8%BE%91%E5%A4%96%E9%94%AE/</url>
    <content><![CDATA[<h2 id="为什么mysql不推荐使用物理外键？"><a href="#为什么mysql不推荐使用物理外键？" class="headerlink" title="为什么mysql不推荐使用物理外键？"></a>为什么mysql不推荐使用物理外键？</h2><p>刚好今天我也遇到了这个问题，在写一个RBAC权限模型时，在设计完数据表之后，创建过程中因为物理外键浪费了不少时间，就来了解一下逻辑外键和物理外键</p>
<a id="more"></a>

<h3 id="1-外键的性能问题"><a href="#1-外键的性能问题" class="headerlink" title="1. 外键的性能问题"></a>1. 外键的性能问题</h3><ul>
<li>外键是一种“约束”。这个约束的存在，会保证关联表之间数据的关系“始终完整”。</li>
<li>数据库需要维护外键的内部管理。</li>
<li>外键等于把数据的一致性事务实现，全部交给数据库服务器完成；</li>
<li>有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源；</li>
<li>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；</li>
</ul>
<h5 id="总的来说物理外键是个比较“重”的实现，它会不顾性能不分轻重缓急的给你保证一致性"><a href="#总的来说物理外键是个比较“重”的实现，它会不顾性能不分轻重缓急的给你保证一致性" class="headerlink" title="总的来说物理外键是个比较“重”的实现，它会不顾性能不分轻重缓急的给你保证一致性"></a>总的来说物理外键是个比较“重”的实现，它会不顾性能不分轻重缓急的给你保证一致性</h5><h3 id="2-不适用物理外键的原因"><a href="#2-不适用物理外键的原因" class="headerlink" title="2. 不适用物理外键的原因"></a>2. 不适用物理外键的原因</h3><ul>
<li>性能：在表上拥有活动的外键可以提高数据质量，但会影响插入、更新和删除操作的性能。在这些任务之前，数据库需要检查它是否违反数据完整性。</li>
<li>全表重新加载：一些数据库，如数据仓库，分段或接口数据库，需要经常从外部重新加载数据。这会导致重新加载时数据不一致</li>
<li>拓展性的限制：如果用了物理外键，你会遵守这个规矩去干活。但是计划赶不上变化，万一那天主键所在表需要拆分了，需要重构了，这种情况并不少见，尤其是数据库设计者水平不够高的情况下。另一方面，数据表之间有了级联关系，极有可能会限制开发者的思维逻辑，导致思路不清晰</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>理解递归</title>
    <url>/2019/07/01/%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>在python中，函数的调用通常发生在彼此不同的函数之间。其实，函数还有一种特殊的调用方式，那就是自己调用自己，这种方式称为函数递归调用。</p>
<p>递归，在程序设计中也是一个常用的技巧，也可以理解为一种<strong>思维方式</strong>，非常值得我们掌握。</p>
<a id="more"></a>

<h3 id="1-什么是递归"><a href="#1-什么是递归" class="headerlink" title="1. 什么是递归"></a>1. 什么是递归</h3><p>简单理解：</p>
<blockquote>
<p>概念：程序调用自身的编程技巧称为递归（ recursion），一个函数直接或间接地调用自身</p>
<p>核心思想：每一次递归目的都是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题，当递归到一定层次，问题就会解决</p>
</blockquote>
<h3 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h3><p>递归的写法：</p>
<p>其实写递归函数，只需要确定以下两个要素就可以了：</p>
<ul>
<li>终止递归的条件</li>
<li>非终止递归条件下，自己调用自己</li>
</ul>
<p>看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_number</span>(<span class="params">n</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        total += i</span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

<p>这是一个简单的累加求和，假设不用递归的情况下，最简便的方法就是循环累加，再来看用递归写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_number_recursion</span>(<span class="params">n</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> n + sum_number_recursion(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>这两个函数的执行结果毋庸置疑都是一样的，但是递归的思想是反着的，并不是从1开始做累加，而是从n开始递减</p>
<p><img src="https://img-blog.csdnimg.cn/20201124225220269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>它们之间的区别就是递归需要判断n是否递减到0，也就是所谓的递归出口。如果一个递归函数缺少递归出口，执行时就会陷入死循环。递归出口通常可用if语句来设置，在满足某种条件时不再继续，调用某个值，结束递归。</p>
<h3 id="3-尾递归"><a href="#3-尾递归" class="headerlink" title="3. 尾递归"></a>3. 尾递归</h3><blockquote>
<p><em>尾递归作为一种代码优化，在效率上相当于循环迭代，且不失递归的简洁优雅</em></p>
</blockquote>
<p>尾递归相对传统递归，其是一种特例。在尾递归中，先执行某部分的计算，然后开始调用递归，所以你可以得到当前的计算结果，而这个结果也将作为参数传入下一次递归。这也就是说函数调用出现在调用者函数的尾部，因为是尾部，所以其有一个优越于传统递归之处在于无需去保存任何局部变量，从内存消耗上，实现节约特性。</p>
<h5 id="传统递归（会将每次调用结果保存到内存中，耗费资源）"><a href="#传统递归（会将每次调用结果保存到内存中，耗费资源）" class="headerlink" title="传统递归（会将每次调用结果保存到内存中，耗费资源）"></a>传统递归（会将每次调用结果保存到内存中，耗费资源）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_number_recursion</span>(<span class="params">n</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> n + sum_number_recursion(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译器执行过程</span></span><br><span class="line"><span class="comment"># 传统递归,会将结果保存到内存中，耗费资源</span></span><br><span class="line"><span class="comment"># 5 + sum_number_recursion(4)</span></span><br><span class="line"><span class="comment"># 5 + (4 + sum_number_recursion(3))</span></span><br><span class="line"><span class="comment"># 5 + (4 + (3 + sum_number_recursion(2))</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<p>这种方式中途你是得不到计算结果，直到所有的递归调用都返回。 这样虽然很大程度上简洁了代码编写，但是让人很难它跟高效联系起来。</p>
<h5 id="尾递归（将结果作为参数传递给下一次调用）"><a href="#尾递归（将结果作为参数传递给下一次调用）" class="headerlink" title="尾递归（将结果作为参数传递给下一次调用）"></a>尾递归（将结果作为参数传递给下一次调用）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail_recursion</span>(<span class="params">n, result=<span class="number">0</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> tail_sum(n<span class="number">-1</span>, result+n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译器执行过程</span></span><br><span class="line"><span class="comment"># tail_recursion(5,0)</span></span><br><span class="line"><span class="comment"># tail_recursion(4,5)</span></span><br><span class="line"><span class="comment"># tail_recursion(3,9)</span></span><br><span class="line"><span class="comment"># tail_recursion(2,12)</span></span><br><span class="line"><span class="comment"># tail_recursion(1,14)</span></span><br><span class="line"><span class="comment"># tail_recursion(0,15)</span></span><br><span class="line"><span class="comment"># 15</span></span><br></pre></td></tr></table></figure>

<p>可以看到当前函数的计算结果作为第二个参数传入下一个递归，使得系统不在需要保留之前计算结果。尾递归的优势显而易见了。</p>
<p>但是python本身不支持尾递归（没有对尾递归做优化），而且对递归的次数有限制，当递归深度超过1000时，会抛出异常：<strong>RecursionError: maximum recursion depth exceeded in comparison</strong></p>
<p>解决方法：重新设置默认递归深度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">100000</span>)</span><br></pre></td></tr></table></figure>

<p>所以尾递归有一个优越于传统递归之处在于无需去保存任何局部变量，从内存消耗上，实现节约特性。</p>
<p>看到这儿，就可以更好的理解递归的本质了：</p>
<p><strong>在你调用了一个函数之后，函数会从内存中开拓出一个新的地方，来保存当前函数的参数变量，以及你在这个函数里面声明的变量。即使是自己调用自己。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>设计模式与开发模式</title>
    <url>/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="设计模式（偏高端）："><a href="#设计模式（偏高端）：" class="headerlink" title="设计模式（偏高端）："></a>设计模式（偏高端）：</h3><p><strong>python有，主要在Java</strong><br><strong>设计模式：单利模式，工厂模式，观察者模式</strong></p>
<br>
<br>

<h3 id="工厂模式最核心的：解耦（减少耦合度）"><a href="#工厂模式最核心的：解耦（减少耦合度）" class="headerlink" title="工厂模式最核心的：解耦（减少耦合度）"></a>工厂模式最核心的：解耦（减少耦合度）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">耦合度高的话 会导致开发维护商等着，</span><br></pre></td></tr></table></figure>

<br>


<h3 id="单利模式-举例子：饭桶-："><a href="#单利模式-举例子：饭桶-：" class="headerlink" title="单利模式(举例子：饭桶)："></a>单利模式(举例子：饭桶)：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每一次实例化对象，对象不做销毁，对象存在内存中。下次实例化时，直接从内存中拿出来用。</span><br><span class="line">节约了实例化的过程，节约了实例化的空间。</span><br></pre></td></tr></table></figure>

<p><strong>单利模式带给我们是 性能上的提升</strong></p>
<p><strong>工厂模式带给我们是 业务上的解耦</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test:</span><br><span class="line">	pass</span><br><span class="line"></span><br><span class="line">a1&#x3D;Test()</span><br><span class="line">a2&#x3D;Test()</span><br><span class="line"></span><br><span class="line"># 内存地址不一致</span><br><span class="line">print(id(a1))</span><br><span class="line">print(id(a2))</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<br>
<br>


<h3 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h3><p><strong>开发模式：MVC,MTV</strong></p>
<br>
<br>

<h3 id="类方法与静态方法的区别："><a href="#类方法与静态方法的区别：" class="headerlink" title="类方法与静态方法的区别："></a>类方法与静态方法的区别：</h3><p><strong>类方法还得实例化对象，静态方法直接调用方法名</strong></p>
<br>
<br>
<br>
]]></content>
      <tags>
        <tag>好</tag>
      </tags>
  </entry>
  <entry>
    <title>解决vscode报错Module &#39;cv2&#39; has no &#39;imread&#39; memberpylint(no-member)</title>
    <url>/2019/09/23/%E8%A7%A3%E5%86%B3vscode%E6%8A%A5%E9%94%99Module-cv2-has-no-imread-memberpylint-no-member/</url>
    <content><![CDATA[<h3 id="解决vscode报错”Module-‘cv2’-has-no-‘imread’-memberpylint-no-member-”"><a href="#解决vscode报错”Module-‘cv2’-has-no-‘imread’-memberpylint-no-member-”" class="headerlink" title="解决vscode报错”Module ‘cv2’ has no ‘imread’ memberpylint(no-member)”"></a>解决vscode报错”Module ‘cv2’ has no ‘imread’ memberpylint(no-member)”</h3><p>先来看以下场景</p>
<p>每个调用cv2的地方都出现了红色下划线，显示Module ‘cv2’ has no ‘xxx’ member，如下</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20201124224942528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>这一点简单的代码在vscode上会报 Module ‘cv2’ has no ‘imshow’ member 的错误，其实代码是没有错的，可以直接运行，是因为vscode的插件检测不到opencv模块</p>
<p>解决办法：</p>
<p>在settings.json中增加代码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;python.linting.pylintArgs&quot;: [&quot;--generate-members&quot;]</span><br></pre></td></tr></table></figure>

<p>这样VScode就不会出现烦人的红色波浪线了,虽然说这红色的波浪线对代码没有影响,但是对于有强迫症的人来说确实真的不舒服。</p>
]]></content>
  </entry>
  <entry>
    <title>那些年让你迷惑的多任务、并行、并发、多线程、多进程</title>
    <url>/2019/12/22/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%AE%A9%E4%BD%A0%E8%BF%B7%E6%83%91%E7%9A%84%E5%A4%9A%E4%BB%BB%E5%8A%A1%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="那些年让你迷惑的多任务、并行、并发、多线程、多进程"><a href="#那些年让你迷惑的多任务、并行、并发、多线程、多进程" class="headerlink" title="那些年让你迷惑的多任务、并行、并发、多线程、多进程"></a>那些年让你迷惑的多任务、并行、并发、多线程、多进程</h2><p>相信多任务，进程，线程，并发，并行，同步，异步，阻塞和非阻塞这几个概念大家在编程过程中肯定会遇到，但是这几个概念又那么类似很容易让人模糊，今天就用这一篇文章来总结一下这几个概念。</p>
<a id="more"></a>

<h3 id="1-什么是多任务"><a href="#1-什么是多任务" class="headerlink" title="1. 什么是多任务"></a>1. 什么是多任务</h3><p>概念：同一时间内，执行多个任务</p>
<p>目的：充分利用CPU资源，提高程序的执行效率</p>
<p>我们首先以单核CPU的情况为前提进行说明</p>
<p>简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听网易云，一边再用typora写博客，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台运行着，只是桌面上没有显示而已。</p>
<p><img src="https://img-blog.csdnimg.cn/20201122231207636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>上面描述的例子是从用户角度来看。我们从程序员观点来看，就是计算机同时执行多段代码。这里用一个示意图来说明程序员的观点的单任务和多任务，假设两件事情需要处理，分别是TASK1,TASK2。</p>
<p><img src="https://img-blog.csdnimg.cn/2020112223124782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Njg0OTYyNw==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>在单任务执行时，首先执行TASK1，当TASK1结束以后，执行TASK2。如果是多任务执行的话，就是TASK1和TASK2交替执行。</p>
<p>那么，单核CPU是怎么执行多任务的呢？</p>
<p>答案就是操作系统轮流让每个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，让我们感觉就像所有任务都在同时执行一样。</p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行</p>
<h3 id="2-并发与并行"><a href="#2-并发与并行" class="headerlink" title="2. 并发与并行"></a>2. 并发与并行</h3><h4 id="并发（Concurrency）"><a href="#并发（Concurrency）" class="headerlink" title="并发（Concurrency）"></a>并发（Concurrency）</h4><blockquote>
<p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201122231321946.png#pic_center"></p>
<h4 id="并行（Parallelism）"><a href="#并行（Parallelism）" class="headerlink" title="并行（Parallelism）"></a>并行（Parallelism）</h4><blockquote>
<p>两个或两个以上事件（或线程）在同一时刻发生是真正意义上的不同事件或线程在同一时刻，在不同CPU资源呢上（多核），同时执行。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20201122231356873.png#pic_center"></p>
<p>用一个例子来说明下并发和并行两个概念。假设你开了一个餐馆，只有一个厨师，但同时有两桌客人点了菜。简称A桌和B桌，为了让两桌客人都满意，你可以安排厨师，交叉地为两桌客人做菜。为A桌做一道菜，再为B桌做一道菜，如此交叉进行，直到做完所有的菜。这个只能叫并发，不能叫并行。如果你多雇一个厨师，两个厨师，一个做A桌的菜，一个做B桌的菜，这个就算并行了。</p>
<p>简单地说：</p>
<p>并发：一个时间段内，程序交替的去执行(单核 CPU 执行多任务，一定是并发)</p>
<p>并行：在多核 CPU 中，多个任务，在不同的 CPU 上，同时执行。</p>
<p>所以，多任务要怎么来实现呢？（使用代码）</p>
<ul>
<li>进程实现</li>
<li>线程实现</li>
<li>协程实现</li>
</ul>
<h3 id="3-进程、线程"><a href="#3-进程、线程" class="headerlink" title="3. 进程、线程"></a>3. 进程、线程</h3><h4 id="3-1-进程（Process）"><a href="#3-1-进程（Process）" class="headerlink" title="3.1 进程（Process）"></a>3.1 进程（Process）</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><blockquote>
<p>进程是资源分配最小单位</p>
<p>当一个可执行程序被系统执行（分配内存等资源）就变成了一个进程</p>
<p>它是正在运行的程序的实例。一台机器上可以有多个进程，每个进程执行不同的程序。多个进程能够同时的存在，并能在同一时间内同时运行。每个进程都有都有独立的代码和数据空间（程序上下文），因此它们之间的资源分配和调度也相互独立。同时运行多个进程，能够最大话利用多核CPU的资源，提升运行速度。</p>
</blockquote>
<h5 id="进程的使用"><a href="#进程的使用" class="headerlink" title="进程的使用"></a>进程的使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 导包</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="comment"># 2. 创建进程对象</span></span><br><span class="line">变量(进程对象) = multiprocessing.Process(target=执行的任务函数)</span><br><span class="line"><span class="comment"># 3. 启动进程对象</span></span><br><span class="line">进程对象.start()</span><br></pre></td></tr></table></figure>

<h5 id="开启多进程"><a href="#开启多进程" class="headerlink" title="开启多进程"></a>开启多进程</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">&#x27;singing...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dance</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">&#x27;dancing...&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在windows下使用多进程需要程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    process_1 = multiprocessing.Process(target=sing)</span><br><span class="line">    process_2 = multiprocessing.Process(target=dance)</span><br><span class="line">    process_1.start()</span><br><span class="line">    process_2.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dancing...</span><br><span class="line">singing...</span><br><span class="line">dancing...</span><br><span class="line">singing...</span><br><span class="line">dancing...</span><br><span class="line">singing...</span><br><span class="line">dancing...</span><br><span class="line">singing...</span><br><span class="line">dancing...</span><br><span class="line">singing...</span><br></pre></td></tr></table></figure>

<h5 id="进程注意点"><a href="#进程注意点" class="headerlink" title="进程注意点"></a>进程注意点</h5><ul>
<li>进程之间不共享全局变量</li>
<li>主进程等待子进程执行结束再结束</li>
<li>进程的执行是无序的，是操作系统调度的</li>
</ul>
<h5 id="进程之间不共享全局变量demo"><a href="#进程之间不共享全局变量demo" class="headerlink" title="进程之间不共享全局变量demo"></a>进程之间不共享全局变量demo</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程之间不共享全局变量，数据彼此独立，互不影响（浪费资源）</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">f&quot;任务1&gt;&gt;&gt;a:<span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = multiprocessing.Process(target=f1)</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    print(<span class="string">f&quot;主进程&gt;&gt;&gt;a:<span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="程序输出-1"><a href="#程序输出-1" class="headerlink" title="程序输出"></a>程序输出</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">任务1&gt;&gt;&gt;a:100</span><br><span class="line">主进程&gt;&gt;&gt;a:0</span><br></pre></td></tr></table></figure>

<p>可以看到，在进程执行完毕之后，全局变量a仍旧为0，得出结论进程之间不共享全局变量</p>
<h4 id="3-2-线程（Thread）"><a href="#3-2-线程（Thread）" class="headerlink" title="3.2 线程（Thread）"></a>3.2 线程（Thread）</h4><p>概念：是 CPU 调度的基本单位。</p>
<blockquote>
<p>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程可以有很多线程，每条线程并行执行不同的任务。但对于python来说，存在GIL 全局解释器锁，它的存在使得一个CPU同一个时刻只能执行一个线程，python的多线程就更像是伪多线程，一个线程运行时，其他线程阻塞，多线程代码不是同时执行，而是交替执行。</p>
</blockquote>
<p>作用：实现多任务的一种方式。</p>
<p>特点：</p>
<ul>
<li>线程是依附在进程，没有进程就没有线程</li>
<li>启动一个程序，默认会有一个进程，一个进程中默认会有一个线程</li>
<li>线程是真正执行任务</li>
<li>在一个进程中可以创建多个线程</li>
</ul>
<h5 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 导入模块</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 2. 创建线程对象</span></span><br><span class="line">threading.Thread(target=执行的任务函数)</span><br><span class="line"><span class="comment"># 3. 启动线程</span></span><br><span class="line">线程对象.start()</span><br></pre></td></tr></table></figure>

<h5 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_1</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        print(<span class="number">1</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_2</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        print(<span class="number">2</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># target：目标、任务，负责指定的任务名称，也就是把函数名放在后面</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 创建子线程</span></span><br><span class="line">    t1 = threading.Thread(target=print_1)</span><br><span class="line">    t2 = threading.Thread(target=print_2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 启动子线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在子线程任务结束之后，输出&quot;任务结束&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 阻塞机制</span></span><br><span class="line">    t1.join()     <span class="comment"># 阻塞主线程，一直到子线程全部结束，才继续执行</span></span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;任务结束&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="程序输出-2"><a href="#程序输出-2" class="headerlink" title="程序输出"></a>程序输出</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">任务结束</span><br></pre></td></tr></table></figure>

<h5 id="线程注意点"><a href="#线程注意点" class="headerlink" title="线程注意点"></a>线程注意点</h5><ul>
<li>线程共享全局变量，同时也会产生资源竞争问题</li>
<li>主线程会等待子线程结束再结束</li>
<li>线程的执行是无序的，是 CPU 调度的</li>
<li>让子线程随着主线程结束而结束，使用：daemon（守护线程）</li>
</ul>
<h5 id="线程资源竞争问题"><a href="#线程资源竞争问题" class="headerlink" title="线程资源竞争问题"></a>线程资源竞争问题</h5><ol>
<li><p>线程同步解决资源竞争问题</p>
<p>同步：协同步调，按照先后顺序执行</p>
<p>线程同步：先执行哪个线程，在执行哪个线程，使用 join() 方法实现。</p>
</li>
<li><p>互斥锁</p>
<p>概念：python 提供的一种机制，同一时刻只有一个线程,能够获得这把锁</p>
<p>作用：保护共享资源</p>
<p>优点：确保了某段关键代码只能由一个线程从头到尾完整地执行</p>
<p>缺点：</p>
<ul>
<li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li>
<li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li>
</ul>
<p>注意点：使用互斥锁，需要保证所有的线程，都要先访问互斥锁，再访问共享资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1. 创建互斥锁</span><br><span class="line">mutex &#x3D; threading.Lock()</span><br><span class="line"># 2. 访问资源前加锁</span><br><span class="line">mutex.acquire()</span><br><span class="line"># 3. 访问资源后,释放锁</span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure>

<p>程序代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        mutex.acquire()</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()</span><br><span class="line">    print(threading.currentThread().name, g_num)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sub_thread1 = threading.Thread(target=func)</span><br><span class="line">    sub_thread2 = threading.Thread(target=func)</span><br><span class="line">    sub_thread1.start()</span><br><span class="line">    sub_thread2.start()</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-1 196249</span><br><span class="line">Thread-2 200000</span><br></pre></td></tr></table></figure>
</li>
<li><p>死锁</p>
<p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p>
</li>
</ol>
<h5 id="GIL：全局解释器锁"><a href="#GIL：全局解释器锁" class="headerlink" title="GIL：全局解释器锁"></a>GIL：全局解释器锁</h5><p>GIL 保证同一时间，只有一个线程使用 CPU，相当于是单线程在执行。</p>
<p>一个进程有一个GIL锁。</p>
<p>GIL 不是 Python 的特性，只是 CPython 解释器的概念。</p>
<h5 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h5><p>类似“<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong>”这样的回答感觉太抽象，都不太容易让人理解。</p>
<p>做个简单的比喻：进程=火车，线程=车厢</p>
<ul>
<li><p>线程在进程下行进（单纯的车厢无法运行）</p>
</li>
<li><p>一个进程可以包含多个线程（一辆火车可以有多个车厢）</p>
</li>
<li><p>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</p>
</li>
<li><p>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</p>
</li>
<li><p>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</p>
</li>
<li><p>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</p>
</li>
<li><p>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</p>
</li>
<li><p>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</p>
</li>
<li><p>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</p>
</li>
</ul>
]]></content>
  </entry>
</search>
